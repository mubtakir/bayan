// Ù…Ø«Ø§Ù„ Ø´Ø§Ù…Ù„ Ù„Ù„Ù‚ÙˆØ§Ø¦Ù… ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙÙŠ Ù„ØºØ© Ø§Ù„Ø¨ÙŠØ§Ù†
// Comprehensive Collections Example in AlBayan

// ========== Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… ÙˆØ§Ù„Ù…ØµÙÙˆÙØ§Øª ==========
// Lists and Arrays

// Ù…Ø«Ø§Ù„ Ø´Ø§Ù…Ù„ Ù„Ù„Ù‚ÙˆØ§Ø¦Ù…
fn comprehensive_lists_example() -> int {
    print("ğŸ“‹ === Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… ÙˆØ§Ù„Ù…ØµÙÙˆÙØ§Øª Ø§Ù„Ø´Ø§Ù…Ù„Ø© ===");
    print("");
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù‚ÙˆØ§Ø¦Ù… Ù…Ø®ØªÙ„ÙØ© Ø§Ù„Ø£Ù†ÙˆØ§Ø¹
    print("ğŸ”¢ === Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… ===");
    
    // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØµØ­ÙŠØ­Ø©
    let numbers: Vec<int> = vec![1, 2, 3, 4, 5, 10, 15, 20];
    print("ğŸ“Š Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯: " + format_int_list(numbers));
    
    // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¹Ø´Ø±ÙŠØ©
    let prices: Vec<float> = vec![10.5, 25.99, 100.0, 75.25, 50.0];
    print("ğŸ’° Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±: " + format_float_list(prices));
    
    // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†ØµÙˆØµ
    let names: Vec<string> = vec!["Ø£Ø­Ù…Ø¯", "ÙØ§Ø·Ù…Ø©", "Ù…Ø­Ù…Ø¯", "Ø¹Ø§Ø¦Ø´Ø©", "Ø¹Ù„ÙŠ"];
    print("ğŸ‘¥ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ù…Ø§Ø¡: " + format_string_list(names));
    
    // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠØ©
    let flags: Vec<bool> = vec![true, false, true, true, false];
    print("ğŸš© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ù„Ø§Ù…: " + format_bool_list(flags));
    
    print("");
    
    // Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
    print("ğŸ”§ === Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===");
    
    // Ø§Ù„Ø·ÙˆÙ„
    print("ğŸ“ Ø·ÙˆÙ„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯: " + string(numbers.len()));
    print("ğŸ“ Ø·ÙˆÙ„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ù…Ø§Ø¡: " + string(names.len()));
    
    // Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø¹Ù†Ø§ØµØ±
    if numbers.len() > 0 {
        print("ğŸ¯ Ø£ÙˆÙ„ Ø¹Ø¯Ø¯: " + string(numbers[0]));
        print("ğŸ¯ Ø¢Ø®Ø± Ø¹Ø¯Ø¯: " + string(numbers[numbers.len() - 1]));
    }
    
    if names.len() > 0 {
        print("ğŸ‘¤ Ø£ÙˆÙ„ Ø§Ø³Ù…: " + names[0]);
        print("ğŸ‘¤ Ø¢Ø®Ø± Ø§Ø³Ù…: " + names[names.len() - 1]);
    }
    
    print("");
    
    // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù…
    print("ğŸ” === Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… ===");
    
    let search_number = 10;
    let found_number = search_in_int_list(numbers, search_number);
    if found_number {
        print("âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ø¯Ø¯ " + string(search_number));
    } else {
        print("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ø¯Ø¯ " + string(search_number));
    }
    
    let search_name = "ÙØ§Ø·Ù…Ø©";
    let found_name = search_in_string_list(names, search_name);
    if found_name {
        print("âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³Ù… " + search_name);
    } else {
        print("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³Ù… " + search_name);
    }
    
    print("");
    
    // Ø§Ù„ØªØ±ØªÙŠØ¨
    print("ğŸ“Š === ØªØ±ØªÙŠØ¨ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… ===");
    let sorted_numbers = sort_int_list(numbers);
    print("ğŸ”¢ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ù…Ø±ØªØ¨Ø©: " + format_int_list(sorted_numbers));
    
    let sorted_names = sort_string_list(names);
    print("ğŸ“ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ù…Ø±ØªØ¨Ø©: " + format_string_list(sorted_names));
    
    print("");
    
    // Ø§Ù„ØªØµÙÙŠØ©
    print("ğŸ” === ØªØµÙÙŠØ© Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… ===");
    let large_numbers = filter_large_numbers(numbers, 5);
    print("ğŸ”¢ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ¨ÙŠØ±Ø© (> 5): " + format_int_list(large_numbers));
    
    let expensive_items = filter_expensive_prices(prices, 50.0);
    print("ğŸ’° Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ù…Ø±ØªÙØ¹Ø© (> 50): " + format_float_list(expensive_items));
    
    let long_names = filter_long_names(names, 4);
    print("ğŸ“ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø·ÙˆÙŠÙ„Ø© (> 4 Ø£Ø­Ø±Ù): " + format_string_list(long_names));
    
    return 0;
}

// ========== Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ø®Ø±Ø§Ø¦Ø· ==========
// Sets and Maps

// Ù…Ø«Ø§Ù„ Ø´Ø§Ù…Ù„ Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
fn comprehensive_sets_example() -> int {
    print("ğŸ—‚ï¸ === Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ø®Ø±Ø§Ø¦Ø· ===");
    print("");
    
    // Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙØ±ÙŠØ¯Ø©
    print("ğŸ”¢ === Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙØ±ÙŠØ¯Ø© ===");
    let numbers_with_duplicates: Vec<int> = vec![1, 2, 3, 2, 4, 1, 5, 3, 6];
    let unique_numbers = create_unique_set(numbers_with_duplicates);
    print("ğŸ“Š Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£ØµÙ„ÙŠØ©: " + format_int_list(numbers_with_duplicates));
    print("âœ¨ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙØ±ÙŠØ¯Ø©: " + format_int_list(unique_numbers));
    
    print("");
    
    // Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„ÙØ±ÙŠØ¯Ø©
    print("ğŸ“ === Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„ÙØ±ÙŠØ¯Ø© ===");
    let words_with_duplicates: Vec<string> = vec!["ÙƒØªØ§Ø¨", "Ù‚Ù„Ù…", "ÙƒØªØ§Ø¨", "Ù…ÙƒØªØ¨", "Ù‚Ù„Ù…", "Ø­Ø§Ø³ÙˆØ¨"];
    let unique_words = create_unique_string_set(words_with_duplicates);
    print("ğŸ“š Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ø£ØµÙ„ÙŠØ©: " + format_string_list(words_with_duplicates));
    print("âœ¨ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„ÙØ±ÙŠØ¯Ø©: " + format_string_list(unique_words));
    
    print("");
    
    // Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
    print("ğŸ”§ === Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ===");
    let set1: Vec<int> = vec![1, 2, 3, 4, 5];
    let set2: Vec<int> = vec![4, 5, 6, 7, 8];
    
    print("ğŸ“Š Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: " + format_int_list(set1));
    print("ğŸ“Š Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: " + format_int_list(set2));
    
    // Ø§Ù„ØªÙ‚Ø§Ø·Ø¹
    let intersection = set_intersection(set1, set2);
    print("ğŸ”— Ø§Ù„ØªÙ‚Ø§Ø·Ø¹: " + format_int_list(intersection));
    
    // Ø§Ù„Ø§ØªØ­Ø§Ø¯
    let union = set_union(set1, set2);
    print("ğŸ”— Ø§Ù„Ø§ØªØ­Ø§Ø¯: " + format_int_list(union));
    
    // Ø§Ù„ÙØ±Ù‚
    let difference = set_difference(set1, set2);
    print("ğŸ”— Ø§Ù„ÙØ±Ù‚ (Ø§Ù„Ø£ÙˆÙ„Ù‰ - Ø§Ù„Ø«Ø§Ù†ÙŠØ©): " + format_int_list(difference));
    
    return 0;
}

// ========== Ø§Ù„Ø®Ø±Ø§Ø¦Ø· ÙˆØ§Ù„Ù‚ÙˆØ§Ù…ÙŠØ³ ==========
// Maps and Dictionaries

// Ù‡ÙŠÙƒÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø®Ø±ÙŠØ·Ø©
struct KeyValuePair {
    key: string,
    value: string
}

struct StringMap {
    pairs: Vec<KeyValuePair>
}

// Ù…Ø«Ø§Ù„ Ø´Ø§Ù…Ù„ Ù„Ù„Ø®Ø±Ø§Ø¦Ø·
fn comprehensive_maps_example() -> int {
    print("ğŸ—ºï¸ === Ø§Ù„Ø®Ø±Ø§Ø¦Ø· ÙˆØ§Ù„Ù‚ÙˆØ§Ù…ÙŠØ³ ===");
    print("");
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ù„Ù„Ø·Ù„Ø§Ø¨ ÙˆØ¯Ø±Ø¬Ø§ØªÙ‡Ù…
    print("ğŸ“ === Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø·Ù„Ø§Ø¨ ÙˆØ§Ù„Ø¯Ø±Ø¬Ø§Øª ===");
    let mut student_grades = create_empty_map();
    
    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let student_grades = map_insert(student_grades, "Ø£Ø­Ù…Ø¯", "85");
    let student_grades = map_insert(student_grades, "ÙØ§Ø·Ù…Ø©", "92");
    let student_grades = map_insert(student_grades, "Ù…Ø­Ù…Ø¯", "78");
    let student_grades = map_insert(student_grades, "Ø¹Ø§Ø¦Ø´Ø©", "95");
    let student_grades = map_insert(student_grades, "Ø¹Ù„ÙŠ", "88");
    
    print("ğŸ“Š Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø¯Ø±Ø¬Ø§Øª:");
    display_map(student_grades);
    
    print("");
    
    // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
    print("ğŸ” === Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø®Ø±ÙŠØ·Ø© ===");
    let search_student = "ÙØ§Ø·Ù…Ø©";
    let grade = map_get(student_grades, search_student);
    if grade != "" {
        print("âœ… Ø¯Ø±Ø¬Ø© " + search_student + ": " + grade);
    } else {
        print("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ " + search_student);
    }
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ù„Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø±
    print("ğŸ›’ === Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¹Ø§Ø± ===");
    let mut product_prices = create_empty_map();
    let product_prices = map_insert(product_prices, "Ù„Ø§Ø¨ØªÙˆØ¨", "2500");
    let product_prices = map_insert(product_prices, "Ù‡Ø§ØªÙ", "800");
    let product_prices = map_insert(product_prices, "ØªØ§Ø¨Ù„Øª", "600");
    let product_prices = map_insert(product_prices, "Ø³Ø§Ø¹Ø© Ø°ÙƒÙŠØ©", "300");
    
    print("ğŸ’° Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:");
    display_map(product_prices);
    
    print("");
    
    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø®Ø±ÙŠØ·Ø©
    print("ğŸ“ˆ === Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø®Ø±Ø§Ø¦Ø· ===");
    print("ğŸ‘¥ Ø¹Ø¯Ø¯ Ø§Ù„Ø·Ù„Ø§Ø¨: " + string(map_size(student_grades)));
    print("ğŸ›’ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª: " + string(map_size(product_prices)));
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙØ§ØªÙŠØ­
    let student_names = map_keys(student_grades);
    print("ğŸ“ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø·Ù„Ø§Ø¨: " + format_string_list(student_names));
    
    let product_names = map_keys(product_prices);
    print("ğŸ·ï¸ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª: " + format_string_list(product_names));
    
    return 0;
}

// ========== Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø© ==========
// Nested Lists

fn comprehensive_nested_lists_example() -> int {
    print("ğŸ”— === Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø© ===");
    print("");
    
    // Ù…ØµÙÙˆÙØ© Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Ù…Ø­Ø§ÙƒØ§Ø©)
    print("ğŸ“Š === Ù…ØµÙÙˆÙØ© Ø§Ù„Ø¯Ø±Ø¬Ø§Øª (3 Ø·Ù„Ø§Ø¨ Ã— 4 Ù…ÙˆØ§Ø¯) ===");
    
    // Ø¯Ø±Ø¬Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨ ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
    let student1_grades: Vec<int> = vec![85, 90, 78, 92];
    let student2_grades: Vec<int> = vec![88, 85, 95, 89];
    let student3_grades: Vec<int> = vec![92, 87, 90, 94];
    
    print("ğŸ‘¤ Ø§Ù„Ø·Ø§Ù„Ø¨ 1: " + format_int_list(student1_grades));
    print("ğŸ‘¤ Ø§Ù„Ø·Ø§Ù„Ø¨ 2: " + format_int_list(student2_grades));
    print("ğŸ‘¤ Ø§Ù„Ø·Ø§Ù„Ø¨ 3: " + format_int_list(student3_grades));
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª
    let avg1 = calculate_average(student1_grades);
    let avg2 = calculate_average(student2_grades);
    let avg3 = calculate_average(student3_grades);
    
    print("ğŸ“Š Ù…ØªÙˆØ³Ø· Ø§Ù„Ø·Ø§Ù„Ø¨ 1: " + string(avg1));
    print("ğŸ“Š Ù…ØªÙˆØ³Ø· Ø§Ù„Ø·Ø§Ù„Ø¨ 2: " + string(avg2));
    print("ğŸ“Š Ù…ØªÙˆØ³Ø· Ø§Ù„Ø·Ø§Ù„Ø¨ 3: " + string(avg3));
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· ÙƒÙ„ Ù…Ø§Ø¯Ø©
    print("");
    print("ğŸ“š === Ù…ØªÙˆØ³Ø· ÙƒÙ„ Ù…Ø§Ø¯Ø© ===");
    
    let subject1_avg = (student1_grades[0] + student2_grades[0] + student3_grades[0]) / 3;
    let subject2_avg = (student1_grades[1] + student2_grades[1] + student3_grades[1]) / 3;
    let subject3_avg = (student1_grades[2] + student2_grades[2] + student3_grades[2]) / 3;
    let subject4_avg = (student1_grades[3] + student2_grades[3] + student3_grades[3]) / 3;
    
    print("ğŸ“– Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø§Ø¯Ø© 1: " + string(subject1_avg));
    print("ğŸ“– Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø§Ø¯Ø© 2: " + string(subject2_avg));
    print("ğŸ“– Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø§Ø¯Ø© 3: " + string(subject3_avg));
    print("ğŸ“– Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø§Ø¯Ø© 4: " + string(subject4_avg));
    
    return 0;
}

// ========== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ù‚ÙˆØ§Ø¦Ù… ==========
// Helper Functions for Lists

// ØªÙ†Ø³ÙŠÙ‚ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØµØ­ÙŠØ­Ø©
fn format_int_list(list: Vec<int>) -> string {
    if list.len() == 0 {
        return "[]";
    }
    
    let result = "[";
    for i in 0..list.len() {
        if i > 0 {
            let result = result + ", ";
        }
        let result = result + string(list[i]);
    }
    let result = result + "]";
    return result;
}

// ØªÙ†Ø³ÙŠÙ‚ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¹Ø´Ø±ÙŠØ©
fn format_float_list(list: Vec<float>) -> string {
    if list.len() == 0 {
        return "[]";
    }
    
    let result = "[";
    for i in 0..list.len() {
        if i > 0 {
            let result = result + ", ";
        }
        let result = result + string(list[i]);
    }
    let result = result + "]";
    return result;
}

// ØªÙ†Ø³ÙŠÙ‚ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†ØµÙˆØµ
fn format_string_list(list: Vec<string>) -> string {
    if list.len() == 0 {
        return "[]";
    }
    
    let result = "[";
    for i in 0..list.len() {
        if i > 0 {
            let result = result + ", ";
        }
        let result = result + "\"" + list[i] + "\"";
    }
    let result = result + "]";
    return result;
}

// ØªÙ†Ø³ÙŠÙ‚ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠØ©
fn format_bool_list(list: Vec<bool>) -> string {
    if list.len() == 0 {
        return "[]";
    }
    
    let result = "[";
    for i in 0..list.len() {
        if i > 0 {
            let result = result + ", ";
        }
        let result = result + if list[i] { "true" } else { "false" };
    }
    let result = result + "]";
    return result;
}

// Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯
fn search_in_int_list(list: Vec<int>, target: int) -> bool {
    for item in list {
        if item == target {
            return true;
        }
    }
    return false;
}

// Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†ØµÙˆØµ
fn search_in_string_list(list: Vec<string>, target: string) -> bool {
    for item in list {
        if item == target {
            return true;
        }
    }
    return false;
}

// ØªØ±ØªÙŠØ¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ (bubble sort Ø¨Ø³ÙŠØ·)
fn sort_int_list(list: Vec<int>) -> Vec<int> {
    let mut sorted = list;
    let n = sorted.len();
    
    for i in 0..n {
        for j in 0..(n-1-i) {
            if sorted[j] > sorted[j+1] {
                let temp = sorted[j];
                sorted[j] = sorted[j+1];
                sorted[j+1] = temp;
            }
        }
    }
    
    return sorted;
}

// ØªØ±ØªÙŠØ¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†ØµÙˆØµ (Ø¨Ø³ÙŠØ·)
fn sort_string_list(list: Vec<string>) -> Vec<string> {
    // Ù…Ø­Ø§ÙƒØ§Ø© ØªØ±ØªÙŠØ¨ Ø¨Ø³ÙŠØ·
    return list; // ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ø³ÙŠØªÙ… ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØµÙˆØµ
}

// ØªØµÙÙŠØ© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ¨ÙŠØ±Ø©
fn filter_large_numbers(list: Vec<int>, threshold: int) -> Vec<int> {
    let mut result: Vec<int> = Vec::new();
    
    for item in list {
        if item > threshold {
            result.push(item);
        }
    }
    
    return result;
}

// ØªØµÙÙŠØ© Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ù…Ø±ØªÙØ¹Ø©
fn filter_expensive_prices(list: Vec<float>, threshold: float) -> Vec<float> {
    let mut result: Vec<float> = Vec::new();
    
    for item in list {
        if item > threshold {
            result.push(item);
        }
    }
    
    return result;
}

// ØªØµÙÙŠØ© Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø·ÙˆÙŠÙ„Ø©
fn filter_long_names(list: Vec<string>, min_length: int) -> Vec<string> {
    let mut result: Vec<string> = Vec::new();
    
    for item in list {
        if item.len() > min_length {
            result.push(item);
        }
    }
    
    return result;
}

// Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© ÙØ±ÙŠØ¯Ø© Ù…Ù† Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯
fn create_unique_set(list: Vec<int>) -> Vec<int> {
    let mut unique: Vec<int> = Vec::new();
    
    for item in list {
        if !search_in_int_list(unique, item) {
            unique.push(item);
        }
    }
    
    return unique;
}

// Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© ÙØ±ÙŠØ¯Ø© Ù…Ù† Ø§Ù„Ù†ØµÙˆØµ
fn create_unique_string_set(list: Vec<string>) -> Vec<string> {
    let mut unique: Vec<string> = Vec::new();
    
    for item in list {
        if !search_in_string_list(unique, item) {
            unique.push(item);
        }
    }
    
    return unique;
}

// ØªÙ‚Ø§Ø·Ø¹ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
fn set_intersection(set1: Vec<int>, set2: Vec<int>) -> Vec<int> {
    let mut result: Vec<int> = Vec::new();
    
    for item in set1 {
        if search_in_int_list(set2, item) {
            result.push(item);
        }
    }
    
    return result;
}

// Ø§ØªØ­Ø§Ø¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
fn set_union(set1: Vec<int>, set2: Vec<int>) -> Vec<int> {
    let mut result = set1;
    
    for item in set2 {
        if !search_in_int_list(result, item) {
            result.push(item);
        }
    }
    
    return result;
}

// ÙØ±Ù‚ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
fn set_difference(set1: Vec<int>, set2: Vec<int>) -> Vec<int> {
    let mut result: Vec<int> = Vec::new();
    
    for item in set1 {
        if !search_in_int_list(set2, item) {
            result.push(item);
        }
    }
    
    return result;
}

// ========== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø®Ø±Ø§Ø¦Ø· ==========
// Helper Functions for Maps

// Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© ÙØ§Ø±ØºØ©
fn create_empty_map() -> StringMap {
    let empty_pairs: Vec<KeyValuePair> = Vec::new();
    return StringMap { pairs: empty_pairs };
}

// Ø¥Ø¯Ø±Ø§Ø¬ ÙÙŠ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
fn map_insert(map: StringMap, key: string, value: string) -> StringMap {
    let mut new_pairs = map.pairs;
    let new_pair = KeyValuePair { key: key, value: value };
    new_pairs.push(new_pair);
    return StringMap { pairs: new_pairs };
}

// Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
fn map_get(map: StringMap, key: string) -> string {
    for pair in map.pairs {
        if pair.key == key {
            return pair.value;
        }
    }
    return "";
}

// Ø­Ø¬Ù… Ø§Ù„Ø®Ø±ÙŠØ·Ø©
fn map_size(map: StringMap) -> int {
    return map.pairs.len();
}

// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙØ§ØªÙŠØ­
fn map_keys(map: StringMap) -> Vec<string> {
    let mut keys: Vec<string> = Vec::new();
    
    for pair in map.pairs {
        keys.push(pair.key);
    }
    
    return keys;
}

// Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
fn display_map(map: StringMap) -> int {
    for pair in map.pairs {
        print("  ğŸ”‘ " + pair.key + " â¡ï¸ " + pair.value);
    }
    return 0;
}

// Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø·
fn calculate_average(grades: Vec<int>) -> int {
    if grades.len() == 0 {
        return 0;
    }
    
    let total = 0;
    for grade in grades {
        let total = total + grade;
    }
    
    return total / grades.len();
}

// ========== Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ==========
// Main Function

fn main() -> int {
    print("ğŸ—‚ï¸ === Ù…Ø«Ø§Ù„ Ø´Ø§Ù…Ù„ Ù„Ù„Ù‚ÙˆØ§Ø¦Ù… ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª === ğŸ—‚ï¸");
    print("âš¡ Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙÙˆØ±ÙŠØ© Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†!");
    print("");
    
    // ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù…Ø«Ù„Ø©
    comprehensive_lists_example();
    print("");
    
    comprehensive_sets_example();
    print("");
    
    comprehensive_maps_example();
    print("");
    
    comprehensive_nested_lists_example();
    print("");
    
    print("ğŸŠ === Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ù…Ø«Ø§Ù„ Ø§Ù„Ø´Ø§Ù…Ù„ ===");
    print("âœ… ØªÙ… Ø¹Ø±Ø¶: Ø§Ù„Ù‚ÙˆØ§Ø¦Ù…ØŒ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§ØªØŒ Ø§Ù„Ø®Ø±Ø§Ø¦Ø·ØŒ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø©");
    print("ğŸ”§ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª: Ø§Ù„Ø¨Ø­Ø«ØŒ Ø§Ù„ØªØ±ØªÙŠØ¨ØŒ Ø§Ù„ØªØµÙÙŠØ©ØŒ Ø§Ù„ØªÙ‚Ø§Ø·Ø¹ØŒ Ø§Ù„Ø§ØªØ­Ø§Ø¯");
    print("ğŸ§¬ Ù„ØºØ© Ø§Ù„Ø¨ÙŠØ§Ù† ØªØ¯Ø¹Ù… Ø¬Ù…ÙŠØ¹ Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ÙƒØ§Ù…Ù„!");
    
    return 0;
}
