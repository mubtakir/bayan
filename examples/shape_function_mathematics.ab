// Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù… ÙˆØ¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ ÙÙŠ Ù„ØºØ© Ø§Ù„Ø¨ÙŠØ§Ù†
// General Shape Equation and Shape Function in AlBayan

// ========== Ø¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ==========
// Basic Shape Function

// Ø¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù…Ø© ÙƒÙ…Ø§ Ø°ÙƒØ±Øª ÙÙŠ ba.md
struct ShapeFunction {
    equation_type: string,      // Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© (Ø®Ø·ÙŠØ©ØŒ Ø¯Ø§Ø¦Ø±ÙŠØ©ØŒ Ù…ÙƒØ¹Ø¨Ø©ØŒ Ø¥Ù„Ø®)
    parameters: Vec<float>,     // Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª (a, b, c, d, ...)
    dimension: int,             // Ø§Ù„Ø¨Ø¹Ø¯ (2D, 3D, 4D, ...)
    complexity_level: float     // Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯
}

// Ø§Ù„ÙƒØ§Ø¦Ù† Ù…Ø¹ Ø¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ h(a, b, d)
struct ObjectWithShape {
    id: string,                 // Ø§Ù„Ù‡ÙˆÙŠØ©
    static_properties: Vec<float>,  // Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ© (a, b)
    shape_function: ShapeFunction,  // Ø¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ (d)
    dynamic_state: Vec<float>   // Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
}

// Ù…Ø¬Ù…ÙˆØ¹Ø© ÙƒØ§Ø¦Ù†Ø§Øª Ù…Ø¹ Ø£Ø´ÙƒØ§Ù„ Ù…ØªØ±Ø§Ø¨Ø·Ø© (Ù…Ø«Ù„ Ø§Ù„Ø¬Ø¯Ø§Ø± Ù…Ù† Ø§Ù„Ù„Ø¨Ù†Ø§Øª)
struct CompositeShape {
    components: Vec<ObjectWithShape>,
    bond_matrix: Vec<Vec<float>>,      // Ù…ØµÙÙˆÙØ© Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
    bond_angles: Vec<Vec<float>>,      // Ø²ÙˆØ§ÙŠØ§ Ø§Ù„Ø§Ù„ØªØ­Ø§Ù…
    emergent_shape: ShapeFunction      // Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù†Ø§Ø´Ø¦
}

// ========== ØªØ·Ø¨ÙŠÙ‚ Ø¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ ==========
// Shape Function Implementation

impl ShapeFunction {
    fn new(equation_type: string, parameters: Vec<float>, dimension: int) -> ShapeFunction {
        let complexity = calculate_shape_complexity(equation_type, parameters, dimension);
        
        return ShapeFunction {
            equation_type: equation_type,
            parameters: parameters,
            dimension: dimension,
            complexity_level: complexity
        };
    }
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø´ÙƒÙ„
    fn evaluate_at_point(self, x: float, y: float, z: float) -> float {
        if self.equation_type == "Ù…Ø³ØªØ·ÙŠÙ„" {
            return evaluate_rectangle(self.parameters, x, y);
        } else if self.equation_type == "Ø¯Ø§Ø¦Ø±Ø©" {
            return evaluate_circle(self.parameters, x, y);
        } else if self.equation_type == "Ù…ÙƒØ¹Ø¨" {
            return evaluate_cube(self.parameters, x, y, z);
        } else if self.equation_type == "ÙƒØ±Ø©" {
            return evaluate_sphere(self.parameters, x, y, z);
        } else {
            return evaluate_general_shape(self.parameters, x, y, z);
        }
    }
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø£Ùˆ Ø§Ù„Ø­Ø¬Ù…
    fn calculate_volume(self) -> float {
        if self.dimension == 2 {
            return calculate_area_2d(self);
        } else if self.dimension == 3 {
            return calculate_volume_3d(self);
        } else {
            return calculate_hypervolume(self);
        }
    }
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø´ÙƒÙ„ (ØªØ¯ÙˆÙŠØ±ØŒ ØªØ­Ø±ÙŠÙƒØŒ ØªÙƒØ¨ÙŠØ±)
    fn transform(self, transformation_matrix: Vec<Vec<float>>) -> ShapeFunction {
        let new_parameters = apply_transformation(self.parameters, transformation_matrix);
        
        return ShapeFunction {
            equation_type: self.equation_type,
            parameters: new_parameters,
            dimension: self.dimension,
            complexity_level: self.complexity_level
        };
    }
}

impl ObjectWithShape {
    fn new(id: string, properties: Vec<float>, shape: ShapeFunction) -> ObjectWithShape {
        return ObjectWithShape {
            id: id,
            static_properties: properties,
            shape_function: shape,
            dynamic_state: Vec::new()
        };
    }
    
    // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ø¯Ù„Ø© h(a, b, d) ÙƒÙ…Ø§ Ø°ÙƒØ±Øª
    fn evaluate_complete_function(self, context_x: float, context_y: float) -> float {
        // a, b Ù‡ÙŠ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        let property_a = get_property_at_index(self.static_properties, 0);
        let property_b = get_property_at_index(self.static_properties, 1);
        
        // d Ù‡ÙŠ Ø¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„
        let shape_value = self.shape_function.evaluate_at_point(context_x, context_y, 0.0);
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© h(a, b, d)
        return combine_properties_with_shape(property_a, property_b, shape_value);
    }
    
    // ØªÙØ§Ø¹Ù„ Ù…Ø¹ ÙƒØ§Ø¦Ù† Ø¢Ø®Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø´ÙƒØ§Ù„
    fn interact_with_shape(self, other: ObjectWithShape, interaction_type: string) -> ObjectWithShape {
        if interaction_type == "Ø§Ù„ØªØ­Ø§Ù…" {
            return bond_shapes(self, other);
        } else if interaction_type == "ØªØ¯Ø§Ø®Ù„" {
            return overlap_shapes(self, other);
        } else if interaction_type == "ØªÙ†Ø§ÙØ±" {
            return repel_shapes(self, other);
        } else {
            return self;
        }
    }
}

impl CompositeShape {
    fn new() -> CompositeShape {
        return CompositeShape {
            components: Vec::new(),
            bond_matrix: Vec::new(),
            bond_angles: Vec::new(),
            emergent_shape: ShapeFunction::new("Ù…Ø±ÙƒØ¨", Vec::new(), 3)
        };
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ù…ÙƒÙˆÙ† Ø¬Ø¯ÙŠØ¯ (Ù…Ø«Ù„ Ù„Ø¨Ù†Ø© ÙÙŠ Ø§Ù„Ø¬Ø¯Ø§Ø±)
    fn add_component(self, component: ObjectWithShape, bond_angle: float) -> CompositeShape {
        let mut new_components = self.components;
        new_components.push(component);
        
        let new_bond_matrix = update_bond_matrix(self.bond_matrix, new_components.len());
        let new_bond_angles = update_bond_angles(self.bond_angles, bond_angle);
        let new_emergent_shape = calculate_emergent_shape(new_components, new_bond_matrix, new_bond_angles);
        
        return CompositeShape {
            components: new_components,
            bond_matrix: new_bond_matrix,
            bond_angles: new_bond_angles,
            emergent_shape: new_emergent_shape
        };
    }
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù†Ø§Ø´Ø¦ Ù…Ù† Ø§Ù„ØªØ±ÙƒÙŠØ¨
    fn calculate_total_shape(self) -> ShapeFunction {
        return self.emergent_shape;
    }
}

// ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ© ==========
// Geometric Shape Functions

// Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„: (x-a)Â²/wÂ² + (y-b)Â²/hÂ² â‰¤ 1
fn evaluate_rectangle(params: Vec<float>, x: float, y: float) -> float {
    let center_x = get_param_at_index(params, 0);
    let center_y = get_param_at_index(params, 1);
    let width = get_param_at_index(params, 2);
    let height = get_param_at_index(params, 3);
    
    let dx = (x - center_x) / width;
    let dy = (y - center_y) / height;
    
    return dx * dx + dy * dy;
}

// Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©: (x-a)Â² + (y-b)Â² = rÂ²
fn evaluate_circle(params: Vec<float>, x: float, y: float) -> float {
    let center_x = get_param_at_index(params, 0);
    let center_y = get_param_at_index(params, 1);
    let radius = get_param_at_index(params, 2);
    
    let dx = x - center_x;
    let dy = y - center_y;
    
    return (dx * dx + dy * dy) - (radius * radius);
}

// Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…ÙƒØ¹Ø¨: |x-a| â‰¤ w/2 && |y-b| â‰¤ h/2 && |z-c| â‰¤ d/2
fn evaluate_cube(params: Vec<float>, x: float, y: float, z: float) -> float {
    let center_x = get_param_at_index(params, 0);
    let center_y = get_param_at_index(params, 1);
    let center_z = get_param_at_index(params, 2);
    let size = get_param_at_index(params, 3);
    
    let dx = abs(x - center_x);
    let dy = abs(y - center_y);
    let dz = abs(z - center_z);
    let half_size = size / 2.0;
    
    if dx <= half_size && dy <= half_size && dz <= half_size {
        return 1.0; // Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…ÙƒØ¹Ø¨
    } else {
        return 0.0; // Ø®Ø§Ø±Ø¬ Ø§Ù„Ù…ÙƒØ¹Ø¨
    }
}

// Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„ÙƒØ±Ø©: (x-a)Â² + (y-b)Â² + (z-c)Â² = rÂ²
fn evaluate_sphere(params: Vec<float>, x: float, y: float, z: float) -> float {
    let center_x = get_param_at_index(params, 0);
    let center_y = get_param_at_index(params, 1);
    let center_z = get_param_at_index(params, 2);
    let radius = get_param_at_index(params, 3);
    
    let dx = x - center_x;
    let dy = y - center_y;
    let dz = z - center_z;
    
    return (dx * dx + dy * dy + dz * dz) - (radius * radius);
}

// Ù…Ø¹Ø§Ø¯Ù„Ø© Ø´ÙƒÙ„ Ø¹Ø§Ù… (Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø­Ø¯ÙˆØ¯)
fn evaluate_general_shape(params: Vec<float>, x: float, y: float, z: float) -> float {
    // Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¹Ø§Ù…Ø©: aâ‚€ + aâ‚x + aâ‚‚y + aâ‚ƒz + aâ‚„xÂ² + aâ‚…yÂ² + aâ‚†zÂ² + aâ‚‡xy + aâ‚ˆxz + aâ‚‰yz + ...
    let mut result = get_param_at_index(params, 0); // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø«Ø§Ø¨Øª
    
    if params.len() > 1 {
        let result = result + get_param_at_index(params, 1) * x; // aâ‚x
    }
    if params.len() > 2 {
        let result = result + get_param_at_index(params, 2) * y; // aâ‚‚y
    }
    if params.len() > 3 {
        let result = result + get_param_at_index(params, 3) * z; // aâ‚ƒz
    }
    if params.len() > 4 {
        let result = result + get_param_at_index(params, 4) * x * x; // aâ‚„xÂ²
    }
    if params.len() > 5 {
        let result = result + get_param_at_index(params, 5) * y * y; // aâ‚…yÂ²
    }
    if params.len() > 6 {
        let result = result + get_param_at_index(params, 6) * z * z; // aâ‚†zÂ²
    }
    if params.len() > 7 {
        let result = result + get_param_at_index(params, 7) * x * y; // aâ‚‡xy
    }
    
    return result;
}

// ========== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ==========
// Helper Functions

fn get_param_at_index(params: Vec<float>, index: int) -> float {
    if index < params.len() {
        return params[index];
    } else {
        return 0.0;
    }
}

fn get_property_at_index(properties: Vec<float>, index: int) -> float {
    if index < properties.len() {
        return properties[index];
    } else {
        return 1.0;
    }
}

fn calculate_shape_complexity(equation_type: string, params: Vec<float>, dimension: int) -> float {
    let base_complexity = float(dimension);
    let param_complexity = float(params.len()) * 0.5;
    
    if equation_type == "Ù…Ø³ØªØ·ÙŠÙ„" || equation_type == "Ù…ÙƒØ¹Ø¨" {
        return base_complexity + param_complexity;
    } else if equation_type == "Ø¯Ø§Ø¦Ø±Ø©" || equation_type == "ÙƒØ±Ø©" {
        return base_complexity + param_complexity + 1.0;
    } else {
        return base_complexity + param_complexity + 2.0;
    }
}

fn combine_properties_with_shape(prop_a: float, prop_b: float, shape_value: float) -> float {
    // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ø¯Ù„Ø© h(a, b, d) = f(a, b) * g(d)
    let property_factor = prop_a * prop_b;
    let shape_factor = 1.0 + shape_value;
    
    return property_factor * shape_factor;
}

fn calculate_area_2d(shape: ShapeFunction) -> float {
    if shape.equation_type == "Ù…Ø³ØªØ·ÙŠÙ„" {
        let width = get_param_at_index(shape.parameters, 2);
        let height = get_param_at_index(shape.parameters, 3);
        return width * height;
    } else if shape.equation_type == "Ø¯Ø§Ø¦Ø±Ø©" {
        let radius = get_param_at_index(shape.parameters, 2);
        return 3.14159 * radius * radius;
    } else {
        return estimate_area_numerical(shape);
    }
}

fn calculate_volume_3d(shape: ShapeFunction) -> float {
    if shape.equation_type == "Ù…ÙƒØ¹Ø¨" {
        let size = get_param_at_index(shape.parameters, 3);
        return size * size * size;
    } else if shape.equation_type == "ÙƒØ±Ø©" {
        let radius = get_param_at_index(shape.parameters, 3);
        return (4.0 / 3.0) * 3.14159 * radius * radius * radius;
    } else {
        return estimate_volume_numerical(shape);
    }
}

fn estimate_area_numerical(shape: ShapeFunction) -> float {
    // ØªÙ‚Ø¯ÙŠØ± Ø¹Ø¯Ø¯ÙŠ Ù„Ù„Ù…Ø³Ø§Ø­Ø©
    return float(shape.parameters.len()) * 10.0;
}

fn estimate_volume_numerical(shape: ShapeFunction) -> float {
    // ØªÙ‚Ø¯ÙŠØ± Ø¹Ø¯Ø¯ÙŠ Ù„Ù„Ø­Ø¬Ù…
    return float(shape.parameters.len()) * 100.0;
}

fn calculate_hypervolume(shape: ShapeFunction) -> float {
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¬Ù… ÙÙŠ Ø£Ø¨Ø¹Ø§Ø¯ Ø£Ø¹Ù„Ù‰
    let dimension_factor = float(shape.dimension);
    let param_factor = float(shape.parameters.len());
    
    return dimension_factor * param_factor * 1000.0;
}

fn apply_transformation(params: Vec<float>, matrix: Vec<Vec<float>>) -> Vec<float> {
    // ØªØ·Ø¨ÙŠÙ‚ ØªØ­ÙˆÙŠÙ„ Ù‡Ù†Ø¯Ø³ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
    let mut new_params: Vec<float> = Vec::new();
    
    for param in params {
        let transformed_param = param * 1.1; // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„
        new_params.push(transformed_param);
    }
    
    return new_params;
}

fn bond_shapes(obj1: ObjectWithShape, obj2: ObjectWithShape) -> ObjectWithShape {
    // Ø§Ù„ØªØ­Ø§Ù… Ø§Ù„Ø£Ø´ÙƒØ§Ù„
    let combined_properties = combine_properties(obj1.static_properties, obj2.static_properties);
    let bonded_shape = create_bonded_shape(obj1.shape_function, obj2.shape_function);
    
    return ObjectWithShape {
        id: obj1.id + "_bonded_" + obj2.id,
        static_properties: combined_properties,
        shape_function: bonded_shape,
        dynamic_state: Vec::new()
    };
}

fn overlap_shapes(obj1: ObjectWithShape, obj2: ObjectWithShape) -> ObjectWithShape {
    // ØªØ¯Ø§Ø®Ù„ Ø§Ù„Ø£Ø´ÙƒØ§Ù„
    return obj1; // Ù…Ø­Ø§ÙƒØ§Ø© Ø¨Ø³ÙŠØ·Ø©
}

fn repel_shapes(obj1: ObjectWithShape, obj2: ObjectWithShape) -> ObjectWithShape {
    // ØªÙ†Ø§ÙØ± Ø§Ù„Ø£Ø´ÙƒØ§Ù„
    return obj1; // Ù…Ø­Ø§ÙƒØ§Ø© Ø¨Ø³ÙŠØ·Ø©
}

fn combine_properties(props1: Vec<float>, props2: Vec<float>) -> Vec<float> {
    let mut combined: Vec<float> = Vec::new();
    
    // Ø¯Ù…Ø¬ Ø§Ù„Ø®ØµØ§Ø¦Øµ
    for prop in props1 {
        combined.push(prop);
    }
    for prop in props2 {
        combined.push(prop);
    }
    
    return combined;
}

fn create_bonded_shape(shape1: ShapeFunction, shape2: ShapeFunction) -> ShapeFunction {
    // Ø¥Ù†Ø´Ø§Ø¡ Ø´ÙƒÙ„ Ù…Ø¯Ù…Ø¬
    let mut combined_params: Vec<float> = Vec::new();
    
    for param in shape1.parameters {
        combined_params.push(param);
    }
    for param in shape2.parameters {
        combined_params.push(param);
    }
    
    return ShapeFunction::new("Ù…Ø¯Ù…Ø¬", combined_params, max(shape1.dimension, shape2.dimension));
}

fn update_bond_matrix(current_matrix: Vec<Vec<float>>, new_size: int) -> Vec<Vec<float>> {
    // ØªØ­Ø¯ÙŠØ« Ù…ØµÙÙˆÙØ© Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
    let mut new_matrix: Vec<Vec<float>> = Vec::new();
    
    for i in 0..new_size {
        let mut row: Vec<float> = Vec::new();
        for j in 0..new_size {
            if i == j {
                row.push(1.0);
            } else {
                row.push(0.0);
            }
        }
        new_matrix.push(row);
    }
    
    return new_matrix;
}

fn update_bond_angles(current_angles: Vec<Vec<float>>, new_angle: float) -> Vec<Vec<float>> {
    // ØªØ­Ø¯ÙŠØ« Ø²ÙˆØ§ÙŠØ§ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
    return current_angles; // Ù…Ø­Ø§ÙƒØ§Ø© Ø¨Ø³ÙŠØ·Ø©
}

fn calculate_emergent_shape(components: Vec<ObjectWithShape>, bonds: Vec<Vec<float>>, angles: Vec<Vec<float>>) -> ShapeFunction {
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù†Ø§Ø´Ø¦ Ù…Ù† Ø§Ù„ØªØ±ÙƒÙŠØ¨
    let total_complexity = float(components.len()) * 2.0;
    let emergent_params = vec![total_complexity, total_complexity * 1.5, total_complexity * 2.0];
    
    return ShapeFunction::new("Ù†Ø§Ø´Ø¦", emergent_params, 3);
}

// ========== Ø£Ù…Ø«Ù„Ø© ØªØ·Ø¨ÙŠÙ‚ÙŠØ© ==========
// Application Examples

fn example_basic_shapes() -> int {
    print("ğŸ“ === Ø£Ù…Ø«Ù„Ø© Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===");
    print("");
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ·ÙŠÙ„
    let rectangle_params = vec![0.0, 0.0, 10.0, 5.0]; // Ù…Ø±ÙƒØ² (0,0)ØŒ Ø¹Ø±Ø¶ 10ØŒ Ø§Ø±ØªÙØ§Ø¹ 5
    let rectangle_shape = ShapeFunction::new("Ù…Ø³ØªØ·ÙŠÙ„", rectangle_params, 2);
    
    print("ğŸ“ Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„:");
    print("   Ø§Ù„Ù…Ø±ÙƒØ²: (0, 0)");
    print("   Ø§Ù„Ø¹Ø±Ø¶: 10ØŒ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹: 5");
    print("   Ø§Ù„Ù…Ø³Ø§Ø­Ø©: " + string(rectangle_shape.calculate_volume()));
    print("");
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø§Ø¦Ø±Ø©
    let circle_params = vec![0.0, 0.0, 3.0]; // Ù…Ø±ÙƒØ² (0,0)ØŒ Ù†ØµÙ Ù‚Ø·Ø± 3
    let circle_shape = ShapeFunction::new("Ø¯Ø§Ø¦Ø±Ø©", circle_params, 2);
    
    print("â­• Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©:");
    print("   Ø§Ù„Ù…Ø±ÙƒØ²: (0, 0)");
    print("   Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±: 3");
    print("   Ø§Ù„Ù…Ø³Ø§Ø­Ø©: " + string(circle_shape.calculate_volume()));
    print("");
    
    return 0;
}

fn example_composite_wall() -> int {
    print("ğŸ§± === Ù…Ø«Ø§Ù„ Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ù…Ø±ÙƒØ¨ Ù…Ù† Ø§Ù„Ù„Ø¨Ù†Ø§Øª ===");
    print("");
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù„Ø¨Ù†Ø§Øª
    let brick_shape = ShapeFunction::new("Ù…ÙƒØ¹Ø¨", vec![0.0, 0.0, 0.0, 2.0], 3);
    let brick_properties = vec![100.0, 50.0]; // Ù‚ÙˆØ©ØŒ ÙˆØ²Ù†
    
    let brick1 = ObjectWithShape::new("Ù„Ø¨Ù†Ø©_1", brick_properties, brick_shape);
    let brick2 = ObjectWithShape::new("Ù„Ø¨Ù†Ø©_2", brick_properties, brick_shape);
    let brick3 = ObjectWithShape::new("Ù„Ø¨Ù†Ø©_3", brick_properties, brick_shape);
    
    // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§Ø±
    let mut wall = CompositeShape::new();
    let wall = wall.add_component(brick1, 0.0);
    let wall = wall.add_component(brick2, 90.0);
    let wall = wall.add_component(brick3, 0.0);
    
    let wall_shape = wall.calculate_total_shape();
    
    print("ğŸ—ï¸ ØªÙ… Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§Ø±:");
    print("   Ø¹Ø¯Ø¯ Ø§Ù„Ù„Ø¨Ù†Ø§Øª: " + string(wall.components.len()));
    print("   Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù†Ø§Ø´Ø¦: " + wall_shape.equation_type);
    print("   Ø§Ù„ØªØ¹Ù‚ÙŠØ¯: " + string(wall_shape.complexity_level));
    print("   Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: " + string(wall_shape.calculate_volume()));
    print("");
    
    return 0;
}

fn example_shape_interaction() -> int {
    print("ğŸ”„ === ØªÙØ§Ø¹Ù„ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ ===");
    print("");
    
    // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù†ÙŠÙ†
    let obj1_shape = ShapeFunction::new("Ø¯Ø§Ø¦Ø±Ø©", vec![0.0, 0.0, 2.0], 2);
    let obj1 = ObjectWithShape::new("ÙƒØ§Ø¦Ù†_1", vec![10.0, 20.0], obj1_shape);
    
    let obj2_shape = ShapeFunction::new("Ù…Ø³ØªØ·ÙŠÙ„", vec![3.0, 0.0, 4.0, 2.0], 2);
    let obj2 = ObjectWithShape::new("ÙƒØ§Ø¦Ù†_2", vec![15.0, 25.0], obj2_shape);
    
    // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ø¯Ù„Ø© h(a, b, d)
    let result1 = obj1.evaluate_complete_function(1.0, 1.0);
    let result2 = obj2.evaluate_complete_function(1.0, 1.0);
    
    print("ğŸ§® ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ø¯Ù„Ø© h(a, b, d):");
    print("   Ø§Ù„ÙƒØ§Ø¦Ù† 1: h(10, 20, Ø¯Ø§Ø¦Ø±Ø©) = " + string(result1));
    print("   Ø§Ù„ÙƒØ§Ø¦Ù† 2: h(15, 25, Ù…Ø³ØªØ·ÙŠÙ„) = " + string(result2));
    print("");
    
    // Ø§Ù„ØªØ­Ø§Ù… Ø§Ù„ÙƒØ§Ø¦Ù†ÙŠÙ†
    let bonded_object = obj1.interact_with_shape(obj2, "Ø§Ù„ØªØ­Ø§Ù…");
    
    print("ğŸ”— Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ø§Ù…:");
    print("   Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯: " + bonded_object.id);
    print("   Ø¹Ø¯Ø¯ Ø§Ù„Ø®ØµØ§Ø¦Øµ: " + string(bonded_object.static_properties.len()));
    print("   Ù†ÙˆØ¹ Ø§Ù„Ø´ÙƒÙ„: " + bonded_object.shape_function.equation_type);
    print("");
    
    return 0;
}

// ========== Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ==========
// Main Function

fn main() -> int {
    print("ğŸ“ === Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù… ÙˆØ¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ === ğŸ“");
    print("âš¡ ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ø¯Ù„Ø© h(a, b, d) ÙƒÙ…Ø§ Ø°ÙƒØ±Øª ÙÙŠ ba.md");
    print("");
    
    // ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£Ù…Ø«Ù„Ø©
    example_basic_shapes();
    example_composite_wall();
    example_shape_interaction();
    
    print("ğŸŠ === Ø§Ù†ØªÙ‡Ù‰ Ù…Ø«Ø§Ù„ Ø¯Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ ===");
    print("âœ… ØªÙ… ØªØ·Ø¨ÙŠÙ‚: Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù…ØŒ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù…Ø±ÙƒØ¨Ø©ØŒ ØªÙØ§Ø¹Ù„ Ø§Ù„Ø£Ø´ÙƒØ§Ù„");
    print("ğŸ“ Ù…Ø¹Ø§Ø¯Ù„Ø© h(a, b, d) Ù…Ø·Ø¨Ù‚Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„!");
    print("ğŸ§¬ Ù„ØºØ© Ø§Ù„Ø¨ÙŠØ§Ù† - Ø­ÙŠØ« ØªÙ„ØªÙ‚ÙŠ Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ø¨Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ø§Ù„Ø­ÙŠØ©!");
    
    return 0;
}
