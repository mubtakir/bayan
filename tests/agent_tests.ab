// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø´Ø§Ù…Ù„Ø© Ù„ÙˆØ­Ø¯Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯
// Comprehensive Tests for Agent Modules
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

use std::agent::types;
use std::agent::nlu;
use std::agent::nlg;
use std::agent::optimizer;
use std::agent::bridge;
use std::agent::core;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ (Types Tests)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn test_intent_creation() {
    let intent = types::create_intent("run", "file.ab", "ar");
    assert(intent.command == "run", "Command should be 'run'");
    assert(intent.language == "ar", "Language should be 'ar'");
    println("âœ… test_intent_creation passed");
}

fn test_response_creation() {
    let response = types::create_response("Success", "ar", true);
    assert(response.message == "Success", "Message should be 'Success'");
    assert(response.language == "ar", "Language should be 'ar'");
    assert(response.success == true, "Success should be true");
    println("âœ… test_response_creation passed");
}

fn test_config_creation() {
    let config = types::create_config("ar", true, 100);
    assert(config.language == "ar", "Language should be 'ar'");
    assert(config.debug == true, "Debug should be true");
    println("âœ… test_config_creation passed");
}

fn test_event_creation() {
    let event = types::create_event("run", "success", 50);
    assert(event.intent == "run", "Intent should be 'run'");
    assert(event.result == "success", "Result should be 'success'");
    println("âœ… test_event_creation passed");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙÙ‡Ù… Ø§Ù„Ù†ÙŠØ© (NLU Tests)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn test_parse_intent_run() {
    let intent = nlu::parse_intent("run file.ab", "en");
    assert(intent.command == "run", "Command should be 'run'");
    assert(intent.parameter.contains("file.ab"), "Parameter should contain 'file.ab'");
    println("âœ… test_parse_intent_run passed");
}

fn test_parse_intent_compile() {
    let intent = nlu::parse_intent("compile code.ab", "en");
    assert(intent.command == "compile", "Command should be 'compile'");
    println("âœ… test_parse_intent_compile passed");
}

fn test_parse_intent_arabic() {
    let intent = nlu::parse_intent("ØªØ´ØºÙŠÙ„ Ù…Ù„Ù.ab", "ar");
    assert(intent.language == "ar", "Language should be 'ar'");
    println("âœ… test_parse_intent_arabic passed");
}

fn test_extract_path() {
    let path = nlu::extract_path("run /home/user/file.ab");
    assert(path.contains("file.ab"), "Path should contain 'file.ab'");
    println("âœ… test_extract_path passed");
}

fn test_extract_code() {
    let code = nlu::extract_code("analyze fn main() { println(\"hello\") }");
    assert(code.contains("main"), "Code should contain 'main'");
    println("âœ… test_extract_code passed");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù„ØºØ© (NLG Tests)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn test_generate_reply_success() {
    let reply = nlg::generate_reply("success", "en");
    assert(reply.contains("success") || reply.contains("Success"), "Reply should mention success");
    println("âœ… test_generate_reply_success passed");
}

fn test_generate_reply_error() {
    let reply = nlg::generate_reply("error", "en");
    assert(reply.contains("error") || reply.contains("Error"), "Reply should mention error");
    println("âœ… test_generate_reply_error passed");
}

fn test_generate_reply_arabic() {
    let reply = nlg::generate_reply_ar("success");
    assert(reply.len() > 0, "Reply should not be empty");
    println("âœ… test_generate_reply_arabic passed");
}

fn test_generate_reply_english() {
    let reply = nlg::generate_reply_en("success");
    assert(reply.len() > 0, "Reply should not be empty");
    println("âœ… test_generate_reply_english passed");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù‘Ù† (Optimizer Tests)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn test_observe_event() {
    let mut agent = types::create_agent("ar", true);
    let event = types::create_event("run", "success", 50);
    optimizer::observe_event(&mut agent, event);
    assert(agent.events.len() > 0, "Events should be recorded");
    println("âœ… test_observe_event passed");
}

fn test_calculate_success_rate() {
    let mut agent = types::create_agent("ar", true);
    let event1 = types::create_event("run", "success", 50);
    let event2 = types::create_event("compile", "success", 30);
    optimizer::observe_event(&mut agent, event1);
    optimizer::observe_event(&mut agent, event2);
    let rate = optimizer::calculate_success_rate(&agent);
    assert(rate >= 0.0 && rate <= 100.0, "Success rate should be between 0 and 100");
    println("âœ… test_calculate_success_rate passed");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¬Ø³Ø± Ø§Ù„ØªÙƒØ§Ù…Ù„ (Bridge Tests)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn test_bridge_creation() {
    let bridge = bridge::create_bridge();
    assert(bridge.compiler_path.len() > 0, "Compiler path should not be empty");
    println("âœ… test_bridge_creation passed");
}

fn test_validate_file() {
    let is_valid = bridge::validate_file("test.ab");
    assert(is_valid == true || is_valid == false, "Should return boolean");
    println("âœ… test_validate_file passed");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù†ÙˆØ§Ø© (Core Tests)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn test_process_input_run() {
    let mut agent = types::create_agent("en", false);
    let response = core::process_input(&mut agent, "run test.ab");
    assert(response.message.len() > 0, "Response should not be empty");
    println("âœ… test_process_input_run passed");
}

fn test_process_input_help() {
    let mut agent = types::create_agent("en", false);
    let response = core::process_input(&mut agent, "help");
    assert(response.message.contains("help") || response.message.contains("Help"), "Response should contain help");
    println("âœ… test_process_input_help passed");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø¯Ø§Ù„Ø© ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn main() {
    println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println("â•‘          ğŸ§ª ØªØ´ØºÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ ğŸ§ª                 â•‘");
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println("");
    
    // Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ø£Ù†ÙˆØ§Ø¹
    println("ğŸ“‹ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ (Types Tests):");
    test_intent_creation();
    test_response_creation();
    test_config_creation();
    test_event_creation();
    println("");
    
    // Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª NLU
    println("ğŸ“‹ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙÙ‡Ù… Ø§Ù„Ù†ÙŠØ© (NLU Tests):");
    test_parse_intent_run();
    test_parse_intent_compile();
    test_parse_intent_arabic();
    test_extract_path();
    test_extract_code();
    println("");
    
    // Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª NLG
    println("ğŸ“‹ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù„ØºØ© (NLG Tests):");
    test_generate_reply_success();
    test_generate_reply_error();
    test_generate_reply_arabic();
    test_generate_reply_english();
    println("");
    
    // Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Optimizer
    println("ğŸ“‹ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù‘Ù† (Optimizer Tests):");
    test_observe_event();
    test_calculate_success_rate();
    println("");
    
    // Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Bridge
    println("ğŸ“‹ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¬Ø³Ø± Ø§Ù„ØªÙƒØ§Ù…Ù„ (Bridge Tests):");
    test_bridge_creation();
    test_validate_file();
    println("");
    
    // Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Core
    println("ğŸ“‹ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù†ÙˆØ§Ø© (Core Tests):");
    test_process_input_run();
    test_process_input_help();
    println("");
    
    println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println("â•‘          âœ… ØªÙ… ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¨Ù†Ø¬Ø§Ø­! âœ…              â•‘");
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
}

