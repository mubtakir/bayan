// tests/programs/dyn_trait_comprehensive_test.ab
// Ø§Ø®ØªØ¨Ø§Ø± Ø´Ø§Ù…Ù„ Ù„Ù†Ø¸Ø§Ù… ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ - Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ù‚ØµÙˆÙ‰ Ù„Ù„Ø®Ø¨ÙŠØ±
// Expert recommendation: "ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ (dyn Trait Ùˆ V-Tables)"
// "Ù‡Ø°Ø§ Ø³ÙŠÙƒÙ…Ù„ Ù‚ØµØ© Traits ÙˆÙŠØ¬Ø¹Ù„ Ø§Ù„Ù„ØºØ© Ù‚ÙˆÙŠØ© ÙˆÙ…Ø±Ù†Ø© Ø¨Ø´ÙƒÙ„ Ù‡Ø§Ø¦Ù„"

/// Ø³Ù…Ø© Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø¹Ø±Ø¶
trait Display {
    fn to_string(&self) -> string;
    fn display(&self) -> string;
}

/// Ø³Ù…Ø© Ù„Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø®
trait Clone {
    fn clone(&self) -> Self;
}

/// Ù‡ÙŠÙƒÙ„ Ø§Ù„ÙƒÙ„Ø¨
struct Dog {
    name: string,
    age: int,
}

/// ØªÙ†ÙÙŠØ° Ø³Ù…Ø© Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù„ÙƒÙ„Ø¨
impl Display for Dog {
    fn to_string(&self) -> string {
        return "Dog: " + self.name;
    }
    
    fn display(&self) -> string {
        return "ğŸ• " + self.name + " (Ø¹Ù…Ø±: " + self.age.to_string() + ")";
    }
}

/// ØªÙ†ÙÙŠØ° Ø³Ù…Ø© Ø§Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø® Ù„Ù„ÙƒÙ„Ø¨
impl Clone for Dog {
    fn clone(&self) -> Dog {
        return Dog {
            name: self.name,
            age: self.age,
        };
    }
}

/// Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù‚Ø·Ø©
struct Cat {
    name: string,
    color: string,
}

/// ØªÙ†ÙÙŠØ° Ø³Ù…Ø© Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù„Ù‚Ø·Ø©
impl Display for Cat {
    fn to_string(&self) -> string {
        return "Cat: " + self.name;
    }
    
    fn display(&self) -> string {
        return "ğŸ± " + self.name + " (Ù„ÙˆÙ†: " + self.color + ")";
    }
}

/// ØªÙ†ÙÙŠØ° Ø³Ù…Ø© Ø§Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø® Ù„Ù„Ù‚Ø·Ø©
impl Clone for Cat {
    fn clone(&self) -> Cat {
        return Cat {
            name: self.name,
            color: self.color,
        };
    }
}

/// Ø§Ø®ØªØ¨Ø§Ø± 1: Ø¥Ù†Ø´Ø§Ø¡ trait objects Ø£Ø³Ø§Ø³ÙŠØ©
fn test_basic_trait_objects() {
    let dog = Dog { name: "Ø¨ÙˆØ¨ÙŠ", age: 3 };
    let cat = Cat { name: "Ù…Ø´Ù…Ø´", color: "Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ" };
    
    // Ø¥Ù†Ø´Ø§Ø¡ trait objects
    let animal1: &dyn Display = &dog;
    let animal2: &dyn Display = &cat;
    
    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø·Ø±Ù‚ Ø¹Ø¨Ø± dynamic dispatch
    let dog_str = animal1.to_string();
    let cat_str = animal2.to_string();
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù†ØªØ§Ø¦Ø¬
    assert(dog_str == "Dog: Ø¨ÙˆØ¨ÙŠ");
    assert(cat_str == "Cat: Ù…Ø´Ù…Ø´");
}

/// Ø§Ø®ØªØ¨Ø§Ø± 2: Ù…ØµÙÙˆÙØ© Ù…Ù† trait objects
fn test_trait_object_array() {
    let dog = Dog { name: "Ø±ÙŠÙƒØ³", age: 5 };
    let cat = Cat { name: "Ù„ÙˆÙ„Ùˆ", color: "Ø£Ø³ÙˆØ¯" };
    
    // Ù…ØµÙÙˆÙØ© Ù…Ù† trait objects
    let animals: List<&dyn Display> = [&dog, &cat];
    
    // Ø§Ù„ØªÙƒØ±Ø§Ø± Ø¹Ø¨Ø± Ø§Ù„Ù…ØµÙÙˆÙØ©
    for animal in animals {
        let display_str = animal.display();
        // ÙƒÙ„ Ø­ÙŠÙˆØ§Ù† Ø³ÙŠØ³ØªØ¯Ø¹ÙŠ ØªÙ†ÙÙŠØ°Ù‡ Ø§Ù„Ø®Ø§Øµ Ù„Ù„Ø·Ø±ÙŠÙ‚Ø©
    }
}

/// Ø§Ø®ØªØ¨Ø§Ø± 3: Ø¯Ø§Ù„Ø© ØªÙ‚Ø¨Ù„ trait object
fn print_animal(animal: &dyn Display) {
    let info = animal.display();
    println(info);
}

/// Ø§Ø®ØªØ¨Ø§Ø± 4: Ø¥Ø±Ø¬Ø§Ø¹ trait object Ù…Ù† Ø¯Ø§Ù„Ø©
fn create_random_animal(is_dog: bool) -> &dyn Display {
    if is_dog {
        let dog = Dog { name: "Ø¹Ø´ÙˆØ§Ø¦ÙŠ", age: 2 };
        return &dog; // Ø¥Ø±Ø¬Ø§Ø¹ trait object
    } else {
        let cat = Cat { name: "Ø¹Ø´ÙˆØ§Ø¦ÙŠ", color: "Ø£Ø¨ÙŠØ¶" };
        return &cat; // Ø¥Ø±Ø¬Ø§Ø¹ trait object
    }
}

/// Ø§Ø®ØªØ¨Ø§Ø± 5: trait objects Ù…Ø¹ multiple traits
fn test_multiple_traits() {
    let dog = Dog { name: "Ù…Ø§ÙƒØ³", age: 4 };
    
    // trait object ÙŠØ¯Ø¹Ù… Ø¹Ø¯Ø© Ø³Ù…Ø§Øª
    let cloneable_animal: &dyn Clone = &dog;
    let displayable_animal: &dyn Display = &dog;
    
    // Ø§Ø³ØªÙ†Ø³Ø§Ø® Ø§Ù„Ø­ÙŠÙˆØ§Ù†
    let cloned_dog = cloneable_animal.clone();
    
    // Ø¹Ø±Ø¶ Ø§Ù„Ø­ÙŠÙˆØ§Ù†
    let display_str = displayable_animal.to_string();
}

/// Ø§Ø®ØªØ¨Ø§Ø± 6: trait object ÙÙŠ struct
struct AnimalContainer {
    animal: &dyn Display,
    name: string,
}

fn test_trait_object_in_struct() {
    let dog = Dog { name: "Ø¨Ø§Ø¯ÙŠ", age: 6 };
    let container = AnimalContainer {
        animal: &dog,
        name: "Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª",
    };
    
    let animal_info = container.animal.display();
}

/// Ø§Ø®ØªØ¨Ø§Ø± 7: trait object Ù…Ø¹ generics
fn process_displayable<T: Display>(item: &T) -> string {
    return item.to_string();
}

fn test_trait_bounds_vs_trait_objects() {
    let dog = Dog { name: "ØªØ´Ø§Ø±Ù„ÙŠ", age: 7 };
    
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… trait bound (static dispatch)
    let static_result = process_displayable(&dog);
    
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… trait object (dynamic dispatch)
    let dynamic_animal: &dyn Display = &dog;
    let dynamic_result = dynamic_animal.to_string();
    
    assert(static_result == dynamic_result);
}

/// Ø§Ø®ØªØ¨Ø§Ø± 8: trait object Ù…Ø¹ ownership
fn test_owned_trait_objects() {
    let dog = Dog { name: "Ø±ÙˆÙƒÙŠ", age: 8 };
    
    // Ù†Ù‚Ù„ Ø§Ù„Ù…Ù„ÙƒÙŠØ© Ø¥Ù„Ù‰ trait object
    let owned_animal: Box<dyn Display> = Box::new(dog);
    let info = owned_animal.display();
}

/// Ø§Ø®ØªØ¨Ø§Ø± 9: trait object method chaining
fn test_method_chaining() {
    let cat = Cat { name: "ÙÙ„Ø§ÙÙŠ", color: "Ø±Ù…Ø§Ø¯ÙŠ" };
    let animal: &dyn Display = &cat;
    
    // Ø³Ù„Ø³Ù„Ø© Ù…Ù† Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª Ø§Ù„Ø·Ø±Ù‚
    let str1 = animal.to_string();
    let str2 = animal.display();
}

/// Ø§Ø®ØªØ¨Ø§Ø± 10: performance comparison
fn test_performance_comparison() {
    let dog = Dog { name: "Ø³Ø¨ÙŠØ¯", age: 9 };
    
    // Static dispatch (compile-time)
    let static_start = get_time();
    for i in 0..1000 {
        let result = dog.to_string();
    }
    let static_end = get_time();
    
    // Dynamic dispatch (runtime)
    let animal: &dyn Display = &dog;
    let dynamic_start = get_time();
    for i in 0..1000 {
        let result = animal.to_string();
    }
    let dynamic_end = get_time();
    
    let static_time = static_end - static_start;
    let dynamic_time = dynamic_end - dynamic_start;
    
    println("Static dispatch time: " + static_time.to_string());
    println("Dynamic dispatch time: " + dynamic_time.to_string());
}

/// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ÙˆÙ‚Øª (Ù…Ø¨Ø³Ø·Ø©)
fn get_time() -> int {
    return 0; // placeholder
}

/// Ø¯Ø§Ù„Ø© main Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±
fn main() {
    println("ğŸŠ Ø§Ø®ØªØ¨Ø§Ø± Ù†Ø¸Ø§Ù… ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ - dyn Trait");
    
    test_basic_trait_objects();
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 1: trait objects Ø£Ø³Ø§Ø³ÙŠØ© - Ù†Ø¬Ø­");
    
    test_trait_object_array();
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 2: Ù…ØµÙÙˆÙØ© trait objects - Ù†Ø¬Ø­");
    
    let dog = Dog { name: "ØªÙŠØ³Øª", age: 1 };
    print_animal(&dog);
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 3: Ø¯Ø§Ù„Ø© ØªÙ‚Ø¨Ù„ trait object - Ù†Ø¬Ø­");
    
    let random_animal = create_random_animal(true);
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 4: Ø¥Ø±Ø¬Ø§Ø¹ trait object - Ù†Ø¬Ø­");
    
    test_multiple_traits();
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 5: multiple traits - Ù†Ø¬Ø­");
    
    test_trait_object_in_struct();
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 6: trait object ÙÙŠ struct - Ù†Ø¬Ø­");
    
    test_trait_bounds_vs_trait_objects();
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 7: trait bounds vs trait objects - Ù†Ø¬Ø­");
    
    test_owned_trait_objects();
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 8: owned trait objects - Ù†Ø¬Ø­");
    
    test_method_chaining();
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 9: method chaining - Ù†Ø¬Ø­");
    
    test_performance_comparison();
    println("âœ… Ø§Ø®ØªØ¨Ø§Ø± 10: performance comparison - Ù†Ø¬Ø­");
    
    println("ğŸŠ Ø¬Ù…ÙŠØ¹ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª dyn Trait Ù†Ø¬Ø­Øª! Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ù…Ø«Ø§Ù„ÙŠ!");
}
