// tests/programs/dangling_reference_prevention_test.ab
// Ø§Ø®ØªØ¨Ø§Ø± Ù…Ù†Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© - Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ù‚ØµÙˆÙ‰ Ù„Ù„Ø®Ø¨ÙŠØ±
// Expert recommendation: "Ù…Ù†Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© (Dangling References) - ØªØ­Ù„ÙŠÙ„ ÙˆÙ‚Øª Ø§Ù„Ø­ÙŠØ§Ø© (Lifetime Analysis)"

/// Ø§Ø®ØªØ¨Ø§Ø± Ø´Ø§Ù…Ù„ Ù„Ù…Ù†Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©
fn main() {
    println!("ğŸš€ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ù…Ù†Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© - Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ù‚ØµÙˆÙ‰ Ù„Ù„Ø®Ø¨ÙŠØ±!");
    
    // Ù‡Ø°Ù‡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙŠØ¬Ø¨ Ø£Ù† ØªÙØ´Ù„ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¯Ù„Ø§Ù„ÙŠ
    // Ù„Ø£Ù†Ù‡Ø§ ØªØ­Ø§ÙˆÙ„ Ø¥Ø±Ø¬Ø§Ø¹ Ù…Ø±Ø§Ø¬Ø¹ Ø¥Ù„Ù‰ Ù…ØªØºÙŠØ±Ø§Øª Ù…Ø­Ù„ÙŠØ©
    
    println!("âœ… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù†Ø¬Ø­Øª - Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© ØªÙ… Ù…Ù†Ø¹Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­!");
}

/// Ø§Ø®ØªØ¨Ø§Ø± 1: Ù…Ø±Ø¬Ø¹ Ù…Ø¨Ø§Ø´Ø± Ø¥Ù„Ù‰ Ù…ØªØºÙŠØ± Ù…Ø­Ù„ÙŠ (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
fn test_direct_local_reference() -> &int {
    let x = 42;
    return &x; // Ø®Ø·Ø£! x Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø©
}

/// Ø§Ø®ØªØ¨Ø§Ø± 2: Ù…Ø±Ø¬Ø¹ Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØºÙŠÙŠØ± Ø¥Ù„Ù‰ Ù…ØªØºÙŠØ± Ù…Ø­Ù„ÙŠ (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
fn test_mutable_local_reference() -> &mut int {
    let mut y = 100;
    return &mut y; // Ø®Ø·Ø£! y Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø©
}

/// Ø§Ø®ØªØ¨Ø§Ø± 3: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ø­Ù‚Ù„ ÙÙŠ struct Ù…Ø­Ù„ÙŠ (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
struct Point {
    x: int,
    y: int,
}

fn test_field_reference_to_local() -> &int {
    let point = Point { x: 10, y: 20 };
    return &point.x; // Ø®Ø·Ø£! point Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø©
}

/// Ø§Ø®ØªØ¨Ø§Ø± 4: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ø¹Ù†ØµØ± ÙÙŠ Ù…ØµÙÙˆÙØ© Ù…Ø­Ù„ÙŠØ© (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
fn test_array_element_reference() -> &int {
    let arr = [1, 2, 3, 4, 5];
    return &arr[0]; // Ø®Ø·Ø£! arr Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø©
}

/// Ø§Ø®ØªØ¨Ø§Ø± 5: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ø¹Ù†ØµØ± ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ù…Ø­Ù„ÙŠØ© (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
fn test_list_element_reference() -> &int {
    let list = List::new();
    list.push(42);
    return &list[0]; // Ø®Ø·Ø£! list Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø©
}

/// Ø§Ø®ØªØ¨Ø§Ø± 6: Ù…Ø±Ø¬Ø¹ Ù…Ø¹Ù‚Ø¯ Ù…Ø¹ ØªØ¯Ø§Ø®Ù„ (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
struct Container {
    data: List<int>,
}

fn test_nested_reference() -> &int {
    let container = Container { data: List::new() };
    container.data.push(123);
    return &container.data[0]; // Ø®Ø·Ø£! container Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø©
}

/// Ø§Ø®ØªØ¨Ø§Ø± 7: Ù…Ø±Ø¬Ø¹ ÙÙŠ if statement (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
fn test_conditional_reference(condition: bool) -> &int {
    if condition {
        let x = 10;
        return &x; // Ø®Ø·Ø£! x Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ if block
    } else {
        let y = 20;
        return &y; // Ø®Ø·Ø£! y Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ else block
    }
}

/// Ø§Ø®ØªØ¨Ø§Ø± 8: Ù…Ø±Ø¬Ø¹ ÙÙŠ match statement (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
enum Option<T> {
    Some(T),
    None,
}

fn test_match_reference(opt: Option<int>) -> &int {
    match opt {
        Option::Some(value) => {
            let local_value = value * 2;
            return &local_value; // Ø®Ø·Ø£! local_value Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ match arm
        }
        Option::None => {
            let default_value = 0;
            return &default_value; // Ø®Ø·Ø£! default_value Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ match arm
        }
    }
}

/// Ø§Ø®ØªØ¨Ø§Ø± 9: Ù…Ø±Ø¬Ø¹ ÙÙŠ loop (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
fn test_loop_reference() -> &int {
    for i in 0..10 {
        let temp = i * i;
        if temp > 25 {
            return &temp; // Ø®Ø·Ø£! temp Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ loop iteration
        }
    }
    
    let fallback = -1;
    return &fallback; // Ø®Ø·Ø£! fallback Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø©
}

/// Ø§Ø®ØªØ¨Ø§Ø± 10: Ù…Ø±Ø¬Ø¹ Ù…Ø¹ ØªØ¯Ø§Ø®Ù„ blocks (ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ´Ù„)
fn test_nested_blocks() -> &int {
    {
        let outer = 100;
        {
            let inner = outer + 50;
            return &inner; // Ø®Ø·Ø£! inner Ø³ØªÙØ¯Ù…ÙÙ‘Ø± Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ inner block
        }
    }
}

// ===== Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ØµØ­ÙŠØ­Ø© (ÙŠØ¬Ø¨ Ø£Ù† ØªÙ†Ø¬Ø­) =====

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 1: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ù…Ø¹Ø§Ù…Ù„ Ø¯Ø§Ù„Ø© (ØµØ­ÙŠØ­)
fn test_parameter_reference(x: &int) -> &int {
    return x; // ØµØ­ÙŠØ­! x Ù‡Ùˆ Ù…Ø¹Ø§Ù…Ù„ØŒ Ù„ÙŠØ³ Ù…ØªØºÙŠØ± Ù…Ø­Ù„ÙŠ
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 2: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ù…ØªØºÙŠØ± global (ØµØ­ÙŠØ­)
static GLOBAL_VALUE: int = 42;

fn test_global_reference() -> &int {
    return &GLOBAL_VALUE; // ØµØ­ÙŠØ­! GLOBAL_VALUE Ù…ØªØºÙŠØ± global
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 3: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ø­Ù‚Ù„ ÙÙŠ Ù…Ø¹Ø§Ù…Ù„ (ØµØ­ÙŠØ­)
fn test_parameter_field_reference(point: &Point) -> &int {
    return &point.x; // ØµØ­ÙŠØ­! point Ù‡Ùˆ Ù…Ø¹Ø§Ù…Ù„
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 4: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ø¹Ù†ØµØ± ÙÙŠ Ù…Ø¹Ø§Ù…Ù„ (ØµØ­ÙŠØ­)
fn test_parameter_element_reference(arr: &[int]) -> &int {
    return &arr[0]; // ØµØ­ÙŠØ­! arr Ù‡Ùˆ Ù…Ø¹Ø§Ù…Ù„
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 5: Ø¥Ø±Ø¬Ø§Ø¹ Ù‚ÙŠÙ…Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ù…Ø±Ø¬Ø¹ (ØµØ­ÙŠØ­)
fn test_return_value() -> int {
    let x = 42;
    return x; // ØµØ­ÙŠØ­! Ø¥Ø±Ø¬Ø§Ø¹ Ù‚ÙŠÙ…Ø©ØŒ Ù„ÙŠØ³ Ù…Ø±Ø¬Ø¹
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 6: Ø¥Ø±Ø¬Ø§Ø¹ Ù…Ø±Ø¬Ø¹ Ù…Ù† Ø¯Ø§Ù„Ø© Ø£Ø®Ø±Ù‰ (ØµØ­ÙŠØ­)
fn get_reference() -> &int {
    return &GLOBAL_VALUE;
}

fn test_function_call_reference() -> &int {
    return get_reference(); // ØµØ­ÙŠØ­! Ø§Ù„Ù…Ø±Ø¬Ø¹ ÙŠØ£ØªÙŠ Ù…Ù† Ø¯Ø§Ù„Ø© Ø£Ø®Ø±Ù‰
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 7: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ static variable (ØµØ­ÙŠØ­)
fn test_static_reference() -> &str {
    static MESSAGE: str = "Hello, World!";
    return &MESSAGE; // ØµØ­ÙŠØ­! MESSAGE Ù‡Ùˆ static
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 8: Ù…Ø±Ø¬Ø¹ Ù…Ø´Ø±ÙˆØ· Ø¥Ù„Ù‰ Ù…Ø¹Ø§Ù…Ù„Ø§Øª (ØµØ­ÙŠØ­)
fn test_conditional_parameter_reference(condition: bool, x: &int, y: &int) -> &int {
    if condition {
        return x; // ØµØ­ÙŠØ­! x Ù‡Ùˆ Ù…Ø¹Ø§Ù…Ù„
    } else {
        return y; // ØµØ­ÙŠØ­! y Ù‡Ùˆ Ù…Ø¹Ø§Ù…Ù„
    }
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 9: Ù…Ø±Ø¬Ø¹ ÙÙŠ match Ù…Ø¹ Ù…Ø¹Ø§Ù…Ù„Ø§Øª (ØµØ­ÙŠØ­)
fn test_match_parameter_reference(opt: Option<&int>, default: &int) -> &int {
    match opt {
        Option::Some(value) => return value, // ØµØ­ÙŠØ­! value Ù‡Ùˆ Ù…Ø±Ø¬Ø¹ Ù…Ù† Ù…Ø¹Ø§Ù…Ù„
        Option::None => return default,      // ØµØ­ÙŠØ­! default Ù‡Ùˆ Ù…Ø¹Ø§Ù…Ù„
    }
}

/// Ø§Ø®ØªØ¨Ø§Ø± ØµØ­ÙŠØ­ 10: Ù…Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ heap-allocated data (ØµØ­ÙŠØ­)
fn test_heap_reference() -> &int {
    let boxed_value = Box::new(42);
    return &*boxed_value; // ØµØ­ÙŠØ­! Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ heap (ØªØ­ØªØ§Ø¬ lifetime annotations Ù…ØªÙ‚Ø¯Ù…Ø©)
}
