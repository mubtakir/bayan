// ============================================================================
// ðŸ§  ÙˆØ­Ø¯Ø© ÙÙ‡Ù… Ø§Ù„Ù†ÙŠØ© Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ© - NLU Module
// ============================================================================
// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ© ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†ÙŠØ© ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

use types;

// ============================================================================
// 1. ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ÙŠØ© Ù…Ù† Ø§Ù„Ù†Øµ
// ============================================================================

fn parse_intent(text: string) -> Intent {
    let intent = "chat";
    let target = "";
    let code = "";
    let hint = "";

    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ©
    if text.contains("Ø´ØºÙ„") || text.contains("ØªØ´ØºÙŠÙ„") || text.contains("run") {
        intent = "run";
        target = extract_path(text);
    } else if text.contains("ØªØ±Ø¬Ù…") || text.contains("compile") || text.contains("Ø¨Ù†Ø§Ø¡") {
        intent = "compile";
        target = extract_path(text);
    } else if text.contains("Ø­Ù„Ù„") || text.contains("analyze") || text.contains("ÙØ­Øµ") {
        intent = "analyze";
        code = extract_code(text);
    } else if text.contains("Ø§Ù‚ØªØ±Ø­") || text.contains("suggest") || text.contains("Ù†ØµÙŠØ­Ø©") {
        intent = "suggest";
        hint = extract_hint(text);
    } else {
        intent = "chat";
        hint = text;
    }

    return types::create_intent(intent, target, code, hint);
}

// ============================================================================
// 2. Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø³Ø§Ø± Ù…Ù† Ø§Ù„Ù†Øµ
// ============================================================================

fn extract_path(text: string) -> string {
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
    if text.contains("examples/") {
        let start = text.find("examples/");
        if start >= 0 {
            let end = start + 20;
            if end > text.len() {
                end = text.len();
            }
            return text.substring(start, end);
        }
    }

    if text.contains(".ab") {
        let start = text.find(".ab");
        if start >= 0 {
            let end = start + 3;
            let begin = 0;
            if start > 20 {
                begin = start - 20;
            }
            return text.substring(begin, end);
        }
    }

    // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¬Ø¯ Ù…Ø³Ø§Ø±ØŒ Ù†Ø±Ø¬Ø¹ Ù†Øµ ÙØ§Ø±Øº
    return "";
}

// ============================================================================
// 3. Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙƒÙˆØ¯ Ù…Ù† Ø§Ù„Ù†Øµ
// ============================================================================

fn extract_code(text: string) -> string {
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ÙƒÙˆØ¯ Ø¨ÙŠÙ† Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø¹ÙŠÙ†Ø©
    if text.contains("```") {
        let start = text.find("```");
        if start >= 0 {
            let end = text.find("```", start + 3);
            if end >= 0 {
                return text.substring(start + 3, end);
            }
        }
    }

    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙˆØ¯ Ù…Ø¨Ø§Ø´Ø±Ø©
    if text.contains("fn ") || text.contains("struct ") || text.contains("let ") {
        return text;
    }

    return "";
}

// ============================================================================
// 4. Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙ„Ù…ÙŠØ­ Ù…Ù† Ø§Ù„Ù†Øµ
// ============================================================================

fn extract_hint(text: string) -> string {
    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© ÙˆØ§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ù‡Ù…
    let hint = text;

    if hint.contains("Ø§Ù‚ØªØ±Ø­") {
        hint = hint.replace("Ø§Ù‚ØªØ±Ø­", "");
    }
    if hint.contains("suggest") {
        hint = hint.replace("suggest", "");
    }
    if hint.contains("Ù†ØµÙŠØ­Ø©") {
        hint = hint.replace("Ù†ØµÙŠØ­Ø©", "");
    }

    return hint;
}

// ============================================================================
// 5. Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
// ============================================================================

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…ÙˆØ¶Ø¹ Ù†Øµ
fn find(text: string, pattern: string) -> int {
    // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø¨Ø³ÙŠØ·
    let i = 0;
    let text_len = text.len();
    let pattern_len = pattern.len();

    while i < text_len {
        if i + pattern_len <= text_len {
            let substr = text.substring(i, i + pattern_len);
            if substr == pattern {
                return i;
            }
        }
        i = i + 1;
    }

    return -1;
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
fn replace(text: string, old: string, new: string) -> string {
    // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¨Ø³ÙŠØ·
    let result = text;
    let pos = find(result, old);

    while pos >= 0 {
        let before = result.substring(0, pos);
        let after = result.substring(pos + old.len(), result.len());
        result = before + new + after;
        pos = find(result, old);
    }

    return result;
}

// ============================================================================
// Ù†Ù‡Ø§ÙŠØ© ÙˆØ­Ø¯Ø© NLU
// ============================================================================

