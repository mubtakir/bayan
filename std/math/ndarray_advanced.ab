// üöÄ Advanced NDArray Operations - Broadcasting & Element-wise Operations
// ÿπŸÖŸÑŸäÿßÿ™ NDArray ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ© - ÿßŸÑÿ®ÿ´ ŸàÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿπŸÜÿµÿ±Ÿäÿ©

use std::math::ndarray::NDArray;

pub struct BroadcastOps;

impl BroadcastOps {
    // ÿ¨ŸÖÿπ ŸÖÿµŸÅŸàŸÅÿ™ŸäŸÜ ŸÖÿπ ÿßŸÑÿ®ÿ´
    pub fn add(a: NDArray, b: NDArray) -> NDArray {
        if a.get_size() == b.get_size() {
            // ŸÜŸÅÿ≥ ÿßŸÑÿ≠ÿ¨ŸÖ - ÿ¨ŸÖÿπ ÿπŸÜÿµÿ±Ÿä ŸÖÿ®ÿßÿ¥ÿ±
            let mut result = NDArray::new(a.get_shape());
            let mut i = 0;
            while i < a.get_size() {
                result.data[i] = a.data[i] + b.data[i];
                i = i + 1;
            }
            return result;
        }
        
        // ÿ®ÿ´ - ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿ£ÿ≠ÿØŸáŸÖÿß ÿπÿØÿØŸä
        if b.get_size() == 1 {
            let scalar = b.data[0];
            let mut result = NDArray::new(a.get_shape());
            let mut i = 0;
            while i < a.get_size() {
                result.data[i] = a.data[i] + scalar;
                i = i + 1;
            }
            return result;
        }
        
        if a.get_size() == 1 {
            let scalar = a.data[0];
            let mut result = NDArray::new(b.get_shape());
            let mut i = 0;
            while i < b.get_size() {
                result.data[i] = scalar + b.data[i];
                i = i + 1;
            }
            return result;
        }
        
        print("Error: Cannot broadcast arrays with incompatible shapes");
        a
    }
    
    // ÿ∑ÿ±ÿ≠ ŸÖÿµŸÅŸàŸÅÿ™ŸäŸÜ ŸÖÿπ ÿßŸÑÿ®ÿ´
    pub fn subtract(a: NDArray, b: NDArray) -> NDArray {
        if a.get_size() == b.get_size() {
            let mut result = NDArray::new(a.get_shape());
            let mut i = 0;
            while i < a.get_size() {
                result.data[i] = a.data[i] - b.data[i];
                i = i + 1;
            }
            return result;
        }
        
        if b.get_size() == 1 {
            let scalar = b.data[0];
            let mut result = NDArray::new(a.get_shape());
            let mut i = 0;
            while i < a.get_size() {
                result.data[i] = a.data[i] - scalar;
                i = i + 1;
            }
            return result;
        }
        
        if a.get_size() == 1 {
            let scalar = a.data[0];
            let mut result = NDArray::new(b.get_shape());
            let mut i = 0;
            while i < b.get_size() {
                result.data[i] = scalar - b.data[i];
                i = i + 1;
            }
            return result;
        }
        
        print("Error: Cannot broadcast arrays with incompatible shapes");
        a
    }
    
    // ÿ∂ÿ±ÿ® ÿπŸÜÿµÿ±Ÿä ŸÖÿπ ÿßŸÑÿ®ÿ´
    pub fn multiply(a: NDArray, b: NDArray) -> NDArray {
        if a.get_size() == b.get_size() {
            let mut result = NDArray::new(a.get_shape());
            let mut i = 0;
            while i < a.get_size() {
                result.data[i] = a.data[i] * b.data[i];
                i = i + 1;
            }
            return result;
        }
        
        if b.get_size() == 1 {
            let scalar = b.data[0];
            let mut result = NDArray::new(a.get_shape());
            let mut i = 0;
            while i < a.get_size() {
                result.data[i] = a.data[i] * scalar;
                i = i + 1;
            }
            return result;
        }
        
        if a.get_size() == 1 {
            let scalar = a.data[0];
            let mut result = NDArray::new(b.get_shape());
            let mut i = 0;
            while i < b.get_size() {
                result.data[i] = scalar * b.data[i];
                i = i + 1;
            }
            return result;
        }
        
        print("Error: Cannot broadcast arrays with incompatible shapes");
        a
    }
    
    // ŸÇÿ≥ŸÖÿ© ÿπŸÜÿµÿ±Ÿäÿ© ŸÖÿπ ÿßŸÑÿ®ÿ´
    pub fn divide(a: NDArray, b: NDArray) -> NDArray {
        if a.get_size() == b.get_size() {
            let mut result = NDArray::new(a.get_shape());
            let mut i = 0;
            while i < a.get_size() {
                if b.data[i] != 0.0 {
                    result.data[i] = a.data[i] / b.data[i];
                } else {
                    result.data[i] = 0.0;
                }
                i = i + 1;
            }
            return result;
        }
        
        if b.get_size() == 1 {
            let scalar = b.data[0];
            if scalar != 0.0 {
                let mut result = NDArray::new(a.get_shape());
                let mut i = 0;
                while i < a.get_size() {
                    result.data[i] = a.data[i] / scalar;
                    i = i + 1;
                }
                return result;
            }
        }
        
        if a.get_size() == 1 {
            let scalar = a.data[0];
            let mut result = NDArray::new(b.get_shape());
            let mut i = 0;
            while i < b.get_size() {
                if b.data[i] != 0.0 {
                    result.data[i] = scalar / b.data[i];
                } else {
                    result.data[i] = 0.0;
                }
                i = i + 1;
            }
            return result;
        }
        
        print("Error: Cannot broadcast arrays with incompatible shapes");
        a
    }
}

// ÿπŸÖŸÑŸäÿßÿ™ ÿπŸÜÿµÿ±Ÿäÿ© ŸÖÿ™ŸÇÿØŸÖÿ©
pub struct ElementWiseOps;

impl ElementWiseOps {
    // ÿ™ÿ∑ÿ®ŸäŸÇ ÿØÿßŸÑÿ© ÿπŸÑŸâ ŸÉŸÑ ÿπŸÜÿµÿ±
    pub fn apply_sqrt(arr: NDArray) -> NDArray {
        let mut result = NDArray::new(arr.get_shape());
        let mut i = 0;
        while i < arr.get_size() {
            result.data[i] = sqrt_approx(arr.data[i]);
            i = i + 1;
        }
        result
    }
    
    // ÿ™ÿ∑ÿ®ŸäŸÇ ÿØÿßŸÑÿ© ÿßŸÑÿ£ÿ≥
    pub fn apply_exp(arr: NDArray) -> NDArray {
        let mut result = NDArray::new(arr.get_shape());
        let mut i = 0;
        while i < arr.get_size() {
            result.data[i] = exp_approx(arr.data[i]);
            i = i + 1;
        }
        result
    }
    
    // ÿ™ÿ∑ÿ®ŸäŸÇ ÿØÿßŸÑÿ© ÿßŸÑŸÑŸàÿ∫ÿßÿ±Ÿäÿ™ŸÖ
    pub fn apply_log(arr: NDArray) -> NDArray {
        let mut result = NDArray::new(arr.get_shape());
        let mut i = 0;
        while i < arr.get_size() {
            if arr.data[i] > 0.0 {
                result.data[i] = log_approx(arr.data[i]);
            } else {
                result.data[i] = 0.0;
            }
            i = i + 1;
        }
        result
    }
    
    // ÿ™ÿ∑ÿ®ŸäŸÇ ÿØÿßŸÑÿ© ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ©
    pub fn apply_abs(arr: NDArray) -> NDArray {
        let mut result = NDArray::new(arr.get_shape());
        let mut i = 0;
        while i < arr.get_size() {
            if arr.data[i] < 0.0 {
                result.data[i] = -arr.data[i];
            } else {
                result.data[i] = arr.data[i];
            }
            i = i + 1;
        }
        result
    }
    
    // ÿ™ÿ∑ÿ®ŸäŸÇ ÿØÿßŸÑÿ© ÿßŸÑÿ™ÿ±ÿ®Ÿäÿπ
    pub fn apply_square(arr: NDArray) -> NDArray {
        let mut result = NDArray::new(arr.get_shape());
        let mut i = 0;
        while i < arr.get_size() {
            result.data[i] = arr.data[i] * arr.data[i];
            i = i + 1;
        }
        result
    }
    
    // ÿ™ÿ∑ÿ®ŸäŸÇ ÿØÿßŸÑÿ© ÿßŸÑŸÖŸÇŸÑŸàÿ®
    pub fn apply_reciprocal(arr: NDArray) -> NDArray {
        let mut result = NDArray::new(arr.get_shape());
        let mut i = 0;
        while i < arr.get_size() {
            if arr.data[i] != 0.0 {
                result.data[i] = 1.0 / arr.data[i];
            } else {
                result.data[i] = 0.0;
            }
            i = i + 1;
        }
        result
    }
}

// ÿØŸàÿßŸÑ ŸÖÿ≥ÿßÿπÿØÿ©
fn sqrt_approx(x: f64) -> f64 {
    if x < 0.0 {
        return 0.0;
    }
    if x == 0.0 {
        return 0.0;
    }
    
    let mut guess = x / 2.0;
    let mut i = 0;
    while i < 10 {
        guess = (guess + x / guess) / 2.0;
        i = i + 1;
    }
    
    guess
}

fn exp_approx(x: f64) -> f64 {
    let mut result = 1.0;
    let mut term = 1.0;
    let mut i = 1;
    while i < 20 {
        term = term * x / (i as f64);
        result = result + term;
        i = i + 1;
    }
    result
}

fn log_approx(x: f64) -> f64 {
    if x <= 0.0 {
        return 0.0;
    }
    
    let mut result = 0.0;
    let mut y = (x - 1.0) / (x + 1.0);
    let mut y_squared = y * y;
    let mut term = y;
    let mut i = 1;
    
    while i < 20 {
        result = result + term / (i as f64);
        term = term * y_squared;
        i = i + 2;
    }
    
    result * 2.0
}

