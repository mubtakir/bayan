// ğŸ§® NDArray - N-Dimensional Array Library for AlBayan
// Ù…ÙƒØªØ¨Ø© Ø§Ù„Ù…ØµÙÙˆÙØ§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ù„Ù„Ø¨ÙŠØ§Ù†

pub struct NDArray {
    data: List<f64>,
    shape: List<i32>,
    strides: List<i32>,
    size: i32,
}

impl NDArray {
    // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ø¬Ø¯ÙŠØ¯Ø©
    pub fn new(shape: List<i32>) -> NDArray {
        let mut size = 1;
        let mut i = 0;
        while i < shape.len() {
            size = size * shape[i];
            i = i + 1;
        }

        let mut data = List::new();
        let mut j = 0;
        while j < size {
            data.push(0.0);
            j = j + 1;
        }

        let strides = NDArray::compute_strides(shape);

        NDArray {
            data: data,
            shape: shape,
            strides: strides,
            size: size,
        }
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù…Ù„ÙˆØ¡Ø© Ø¨Ø§Ù„Ø£ØµÙØ§Ø±
    pub fn zeros(shape: List<i32>) -> NDArray {
        NDArray::new(shape)
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù…Ù„ÙˆØ¡Ø© Ø¨Ø§Ù„ÙˆØ§Ø­Ø¯Ø§Øª
    pub fn ones(shape: List<i32>) -> NDArray {
        let mut arr = NDArray::new(shape);
        let mut i = 0;
        while i < arr.size {
            arr.data[i] = 1.0;
            i = i + 1;
        }
        arr
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ø¨Ù‚ÙŠÙ…Ø© Ø«Ø§Ø¨ØªØ©
    pub fn full(shape: List<i32>, value: f64) -> NDArray {
        let mut arr = NDArray::new(shape);
        let mut i = 0;
        while i < arr.size {
            arr.data[i] = value;
            i = i + 1;
        }
        arr
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ù†ØµØ± Ù…Ù† Ø§Ù„Ù…ØµÙÙˆÙØ©
    pub fn get(self, indices: List<i32>) -> f64 {
        let flat_index = self.compute_flat_index(indices);
        self.data[flat_index]
    }

    // ØªØ¹ÙŠÙŠÙ† Ù‚ÙŠÙ…Ø© Ù„Ø¹Ù†ØµØ± ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
    pub fn set(mut self, indices: List<i32>, value: f64) {
        let flat_index = self.compute_flat_index(indices);
        self.data[flat_index] = value;
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Ø§Ù„Ù…ØµÙÙˆÙØ©
    pub fn get_shape(self) -> List<i32> {
        self.shape
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù†Ø§ØµØ±
    pub fn get_size(self) -> i32 {
        self.size
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
    pub fn get_ndim(self) -> i32 {
        self.shape.len()
    }

    // ØªØºÙŠÙŠØ± Ø´ÙƒÙ„ Ø§Ù„Ù…ØµÙÙˆÙØ©
    pub fn reshape(self, new_shape: List<i32>) -> NDArray {
        let mut new_size = 1;
        let mut i = 0;
        while i < new_shape.len() {
            new_size = new_size * new_shape[i];
            i = i + 1;
        }

        if new_size != self.size {
            print("Error: Cannot reshape array with different size");
            return self;
        }

        let new_strides = NDArray::compute_strides(new_shape);

        NDArray {
            data: self.data,
            shape: new_shape,
            strides: new_strides,
            size: self.size,
        }
    }

    // Ù†Ù‚Ù„ Ø§Ù„Ù…ØµÙÙˆÙØ© (ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯)
    pub fn transpose(self) -> NDArray {
        if self.get_ndim() != 2 {
            print("Error: Transpose only works for 2D arrays");
            return self;
        }

        let rows = self.shape[0];
        let cols = self.shape[1];
        let mut transposed = NDArray::new(List::from([cols, rows]));

        let mut i = 0;
        while i < rows {
            let mut j = 0;
            while j < cols {
                let value = self.get(List::from([i, j]));
                transposed.set(List::from([j, i]), value);
                j = j + 1;
            }
            i = i + 1;
        }

        transposed
    }

    // Ø¬Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ±
    pub fn sum(self) -> f64 {
        let mut total = 0.0;
        let mut i = 0;
        while i < self.size {
            total = total + self.data[i];
            i = i + 1;
        }
        total
    }

    // Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¹Ù†Ø§ØµØ±
    pub fn mean(self) -> f64 {
        self.sum() / (self.size as f64)
    }

    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰
    pub fn max(self) -> f64 {
        let mut max_val = self.data[0];
        let mut i = 1;
        while i < self.size {
            if self.data[i] > max_val {
                max_val = self.data[i];
            }
            i = i + 1;
        }
        max_val
    }

    // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰
    pub fn min(self) -> f64 {
        let mut min_val = self.data[0];
        let mut i = 1;
        while i < self.size {
            if self.data[i] < min_val {
                min_val = self.data[i];
            }
            i = i + 1;
        }
        min_val
    }

    // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø©: Ø­Ø³Ø§Ø¨ Ø§Ù„ÙÙ‡Ø±Ø³ Ø§Ù„Ù…Ø³Ø·Ø­
    fn compute_flat_index(self, indices: List<i32>) -> i32 {
        let mut flat_index = 0;
        let mut i = 0;
        while i < indices.len() {
            flat_index = flat_index + indices[i] * self.strides[i];
            i = i + 1;
        }
        flat_index
    }

    // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø©: Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø·ÙˆØ§Øª
    fn compute_strides(shape: List<i32>) -> List<i32> {
        let mut strides = List::new();
        let mut stride = 1;
        let mut i = shape.len() - 1;

        while i >= 0 {
            strides.push(stride);
            stride = stride * shape[i];
            i = i - 1;
        }

        // Ø¹ÙƒØ³ Ø§Ù„ØªØ±ØªÙŠØ¨
        let mut reversed = List::new();
        let mut j = strides.len() - 1;
        while j >= 0 {
            reversed.push(strides[j]);
            j = j - 1;
        }

        reversed
    }

    // Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù…ØµÙÙˆÙØ©
    pub fn print(self) {
        print("NDArray(shape=");
        print(self.shape);
        print(", size=");
        print(self.size);
        print(")");
    }
}

// Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¹Ø§Ù…Ø©
pub fn array(data: List<f64>) -> NDArray {
    let shape = List::from([data.len() as i32]);
    let strides = List::from([1]);

    NDArray {
        data: data,
        shape: shape,
        strides: strides,
        size: data.len() as i32,
    }
}

pub fn arange(start: f64, end: f64, step: f64) -> NDArray {
    let mut data = List::new();
    let mut current = start;

    while current < end {
        data.push(current);
        current = current + step;
    }

    array(data)
}

pub fn linspace(start: f64, end: f64, num: i32) -> NDArray {
    let mut data = List::new();
    let step = (end - start) / ((num - 1) as f64);
    let mut i = 0;

    while i < num {
        data.push(start + (i as f64) * step);
        i = i + 1;
    }

    array(data)
}

// Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙ‚Ø·ÙŠØ¹ (Slicing)
impl NDArray {
    // ØªÙ‚Ø·ÙŠØ¹ 1D
    pub fn slice_1d(self, start: i32, end: i32) -> NDArray {
        if self.get_ndim() != 1 {
            print("Error: slice_1d only works for 1D arrays");
            return self;
        }

        let mut sliced_data = List::new();
        let mut i = start;
        while i < end && i < self.size {
            sliced_data.push(self.data[i]);
            i = i + 1;
        }

        array(sliced_data)
    }

    // ØªÙ‚Ø·ÙŠØ¹ 2D
    pub fn slice_2d(self, row_start: i32, row_end: i32, col_start: i32, col_end: i32) -> NDArray {
        if self.get_ndim() != 2 {
            print("Error: slice_2d only works for 2D arrays");
            return self;
        }

        let rows = self.shape[0];
        let cols = self.shape[1];
        let new_rows = row_end - row_start;
        let new_cols = col_end - col_start;

        let mut sliced = NDArray::new(List::from([new_rows, new_cols]));

        let mut i = row_start;
        while i < row_end {
            let mut j = col_start;
            while j < col_end {
                let value = self.get(List::from([i, j]));
                sliced.set(List::from([i - row_start, j - col_start]), value);
                j = j + 1;
            }
            i = i + 1;
        }

        sliced
    }

    // ØªÙ‚Ø·ÙŠØ¹ Ù…Ø¹ Ø®Ø·ÙˆØ©
    pub fn slice_with_step(self, start: i32, end: i32, step: i32) -> NDArray {
        if self.get_ndim() != 1 {
            print("Error: slice_with_step only works for 1D arrays");
            return self;
        }

        let mut sliced_data = List::new();
        let mut i = start;
        while i < end && i < self.size {
            sliced_data.push(self.data[i]);
            i = i + step;
        }

        array(sliced_data)
    }
}
