

***

### **المرحلة الأولى: الأساس والمواصفات (The Blueprint)**

**الهدف:** تحديد هوية لغة "البيان" (AlBayan)، فلسفتها، وقواعدها الأساسية. هذه المرحلة هي المخطط الهندسي الذي سيتم بناء المترجم والنظام البيئي بأكمله عليه.

**1. الهوية والفلسفة (Identity & Philosophy):**

*   **الاسم:** البيان (AlBayan).
*   **المعنى:** الاسم عربي الأصل ويعني الوضوح، الفصاحة، والقدرة على التعبير والتبيين.
*   **الفلسفة الأساسية:**
    *   **منصة متكاملة:** لغة ومنصة لتطوير أنظمة ذكية ومعقدة تتفاعل مع العوالم الرقمية والمادية والمعرفية.
    *   **تكامل عميق:** دمج أصيل للبرمجة المنطقية، الذكاء الاصطناعي، والبرمجة التقليدية (الإجرائية، الكائنية، الوظيفية).
    *   **أداء عالٍ وسلامة:** أداء يقارب اللغات الأصلية (Native) مع ضمان سلامة الذاكرة عبر نظام ملكية واستعارة (Ownership & Borrowing).
    *   **تعبيرية ووضوح:** بناء جملة (Syntax) واضح ودقيق يقلل الغموض ويعزز فهم القصد من الكود.
    *   **التخصص المدمج:** دعم مجالات متخصصة (AI, Graphics, Physics, NLP) كمكونات أساسية وليست مجرد مكتبات إضافية.
    *   **قابلية التوسع:** تصميم يسمح ببناء لغات متخصصة (DSLs) وأدوات متقدمة فوق اللغة.

**2. البنية المعجمية (Lexical Structure):**

*   **مجموعة الأحرف:** UTF-8، لدعم جميع اللغات الطبيعية.
*   **المعرفات (Identifiers):**
    *   **القواعد:** تبدأ بحرف (a-z, A-Z) أو `_`، وتتبعها أحرف أو أرقام أو `_`.
    *   **الاصطلاح:**
        *   `CamelCase`: للأنواع (Classes, Structs, Enums, Interfaces) والمتغيرات المنطقية.
        *   `snake_case`: للمتغيرات، الدوال، الوحدات (Modules)، والعلاقات المنطقية.
*   **الكلمات المفتاحية (Keywords):**
    *   **التعريفات:** `fn`, `class`, `interface`, `enum`, `struct`, `let`, `mut`, `const`, `type`.
    *   **هياكل التحكم:** `if`, `else`, `match`, `for`, `in`, `while`, `loop`, `return`, `break`, `continue`.
    *   **المنطق:** `relation`, `fact`, `rule`, `query_solve`, `query_prove`, `assert`, `retract`.
    *   **الذكاء الاصطناعي:** `model`, `tensor`.
    *   **التزامن:** `async`, `await`, `gpu`.
    *   **الوحدات:** `module`, `using`, `pub`, `priv`.
    *   **متفرقات:** `self`, `super`, `init`, `dynamic`, `true`, `false`, `null`.
*   **المعاملات والفواصل:** تتضمن المعاملات الحسابية (`+`, `*`)، المقارنة (`==`, `>`)، المنطقية (`&&`, `!`)، والخاصة بالمنطق (`:-`). الفواصل المنقوطة (`;`) تُستخدم لإنهاء الجمل الإجرائية.

**3. نظام الأنواع الأساسي (Core Type System):**

*   **الأنواع الأولية:**
    *   **الأعداد الصحيحة:** `int` (i64)، `i8`, `i32`, `uint` (u64)، `u8`, `u32`, `usize`.
    *   **الأعداد العشرية:** `float` (f64)، `f32`.
    *   **المنطقية:** `bool`.
    *   **النصوص:** `string` (مملوكة، UTF-8)، `str` (مستعارة، UTF-8).
    *   **الحروف:** `char` (Unicode).
*   **الأنواع المركبة:**
    *   `list<T>`: قائمة ديناميكية.
    *   `array<T, N>`: مصفوفة ثابتة الحجم.
    *   `dict<K, V>`: قاموس (Hash Map).
    *   `tuple<T1, T2, ...>`: مجموعة مرتبة ثابتة.
    *   `set<T>`: مجموعة فريدة.
*   **الأنواع الجبرية (ADTs):** يتم تعريفها باستخدام `struct` (لتجميع الحقول) و `enum` (لتحديد أحد الخيارات الممكنة).
    *   `struct User { id: uint, name: string }`
    *   `enum Option<T> = Some(T) | None;`
*   **النوع الديناميكي:** `dynamic` للتعامل مع الأنواع غير المحددة وقت الترجمة.
*   **أنواع المجالات المتخصصة (أمثلة):**
    *   **AI:** `Tensor`, `Model`.
    *   **Graphics:** `Vec3f`, `Mat4f`, `SceneGraph`, `Mesh`, `Material`.
    *   **Physics:** `RigidBody`, `ColliderShape`, `PhysicsWorld`.
    *   **NLP:** `Document`, `Token`, `EmbeddingVector`.

**4. موجز بناء الجملة (Syntax Sketch):**

```albayancode
// دالة بسيطة
fn add(a: int, b: int) -> int {
    return a + b;
}

// تعريف هيكل (Struct)
struct GameObject {
    id: uint;
    name: string;
    position: Vec3f;
}

// تعريف علاقة وقاعدة منطقية
relation Parent(string, string);
rule Grandparent(GP, GC) :- Parent(GP, P), Parent(P, GC);

// استعلام منطقي داخل كود إجرائي
fn find_grandparents() {
    // ... (تأكيد الحقائق) ...
    query_solve { Grandparent("أحمد", GrandChild) } => {
        print("وجدنا حفيدًا لأحمد: ${GrandChild}");
    }
}
```

**الخلاصة:** هذه المرحلة تحدد "ما هي" لغة البيان. المواصفات المذكورة أعلاه هي العقد الذي يجب على المترجم الوفاء به. المرحلة التالية ستبدأ في بناء المترجم نفسه لفهم هذه القواعد.

**عندما تكون جاهزًا، اطلب "المرحلة الثانية".**


 

***

### **المرحلة الثانية: فهم النص - المحلل المعجمي والنحوي (The Parser)**

**الهدف:** تحويل الكود المصدري المكتوب بلغة البيان من مجرد سلسلة نصية إلى هيكل منظم ومنطقي يفهمه المترجم. هذه المرحلة هي بمثابة "قراءة وفهم القواعد النحوية" للكود.

تتكون هذه المرحلة من مكونين رئيسيين:

**1. المحلل المعجمي (Lexer / Tokenizer):**

*   **الوظيفة:** يقوم المحلل المعجمي بمسح الكود المصدري حرفًا بحرف، ويقوم بتجميعها في وحدات أساسية ذات معنى تُسمى "الرموز" (Tokens). يمكن تشبيهه بتقسيم جملة إنجليزية إلى كلمات منفصلة وعلامات ترقيم.
*   **المدخلات:** سلسلة نصية (الكود المصدري).
    ```
    let answer = 42;
    ```
*   **المخرجات:** سلسلة من الرموز (Stream of Tokens).
    ```
    [Keyword(Let), Identifier("answer"), Operator(Eq), Literal(Int(42)), Semicolon]
    ```
*   **المهام الرئيسية:**
    *   **التعرف على الكلمات المفتاحية:** مثل `fn`, `let`, `if`, `rule`.
    *   **التعرف على المعرفات:** مثل أسماء المتغيرات والدوال `answer`, `main`.
    *   **التعرف على القيم الحرفية (Literals):** مثل الأرقام `42` والنصوص `"Hello"`.
    *   **التعرف على المعاملات والفواصل:** مثل `+`, `=`, `*`, `;`, `{}`.
    *   **تجاهل غير المهم:** يتجاهل المسافات البيضاء، الأسطر الجديدة، والتعليقات.
*   **الأداة المقترحة للتنفيذ:** مكتبة `logos` في لغة Rust، لسرعتها وسهولة استخدامها.

**2. المحلل النحوي (Parser):**

*   **الوظيفة:** يأخذ المحلل النحوي سلسلة الرموز من المحلل المعجمي ويتحقق مما إذا كانت تتبع القواعد النحوية للغة البيان. إذا كان الترتيب صحيحًا، فإنه يبني "شجرة النحو المجردة" (Abstract Syntax Tree - AST)، وهي تمثيل هرمي لهيكل الكود. إذا كان الترتيب خاطئًا، فإنه يبلغ عن خطأ نحوي.
*   **المدخلات:** سلسلة من الرموز من المحلل المعجمي.
    ```
    [Keyword(Let), Identifier("x"), Operator(Eq), Literal(Int(10)), Operator(Plus), Literal(Int(5)), Semicolon]
    ```
*   **المخرجات:** شجرة النحو المجردة (AST).
    ```
    LetStatement
    ├── name: "x"
    └── initializer:
        └── BinaryOperation
            ├── operator: +
            ├── left:
            │   └── Literal(Int(10))
            └── right:
                └── Literal(Int(5))
    ```
*   **المهام الرئيسية:**
    *   **التحقق من صحة بناء الجملة:** التأكد من أن الكود يتبع قواعد اللغة (مثلاً، جملة `let` يجب أن يتبعها اسم متغير).
    *   **معالجة الأسبقية:** فهم أن `*` و `/` لهما أسبقية على `+` و `-`.
    *   **بناء الـ AST:** إنشاء الهيكل الشجري الذي يمثل الكود للمراحل اللاحقة.
    *   **الإبلاغ عن الأخطاء:** إعطاء رسائل خطأ واضحة عند وجود خطأ في بناء الجملة.
*   **الأداة المقترحة للتنفيذ:** مكتبة `chumsky` في لغة Rust، لقوتها في بناء المحللات وتوفير استرداد جيد للأخطاء.

**3. شجرة النحو المجردة (Abstract Syntax Tree - AST):**

*   **الأهمية:** الـ AST هي الناتج النهائي لهذه المرحلة والمدخل الرئيسي لجميع المراحل التالية في المترجم. إنها بنية البيانات المركزية التي تمثل الكود البرمجي بعد فهم هيكله. كل عمليات التحقق من المعنى، التحسين، وتوليد الكود ستعمل على هذه الشجرة.
*   **التنفيذ:** يتم تعريفها في الكود (باستخدام `struct` و `enum` في Rust) لتمثيل كل عقدة ممكنة في اللغة: `FunctionDecl` (تعريف دالة)، `IfStmt` (جملة if)، `BinaryOperation` (عملية ثنائية)، وهكذا.

**الخلاصة:** هذه المرحلة تحول الكود من نص غير مهيكل إلى بنية شجرية مفهومة ومنطقية (AST)، مع التحقق من خلوه من الأخطاء النحوية. أصبح الكود الآن جاهزًا للمرحلة التالية، حيث سنقوم بفحص "معنى" هذا الهيكل.

***

### **المرحلة الثالثة: فحص المعنى - التحليل الدلالي (The Type Checker & Analyzer)**

**الهدف:** التحقق من أن شجرة النحو المجردة (AST) التي تم إنشاؤها في المرحلة السابقة ليست صحيحة نحويًا فحسب، بل "منطقية" وذات معنى في سياق قواعد لغة البيان العميقة. هذه المرحلة تجيب على أسئلة مثل: "هل هذا المتغير مُعرَّف؟"، "هل يمكنك جمع رقم مع نص؟"، "هل هذه الدالة تُرجع النوع الصحيح؟".

هذه المرحلة هي "عقل" المترجم الذي يفهم القصد من الكود ويربط أجزاءه ببعضها.

**1. المرور على مرحلتين (Two-Pass Analysis):**

يتم التحليل الدلالي عادةً على مرحلتين لتسهيل التعامل مع "الاعتماديات الأمامية" (استخدام دالة قبل تعريفها في الملف):

*   **المرور الأول (جمع التعريفات - Symbol Collection):**
    *   **المهمة:** يمر المحلل على الـ AST سريعًا لجمع معلومات عن جميع "الأسماء" المعرّفة في كل نطاق (Scope) — مثل أسماء الدوال، الهياكل (Structs)، الفئات (Classes)، التعدادات (Enums)، والسمات (Traits/Interfaces).
    *   **الناتج:** يتم تسجيل هذه المعلومات (الاسم، النوع، النطاق) في **جدول الرموز (Symbol Table)**. لا يتم تحليل أجسام الدوال في هذه المرحلة، فقط توقيعاتها.

*   **المرور الثاني (التحليل التفصيلي - Detailed Analysis):**
    *   **المهمة:** يمر المحلل مرة أخرى على الـ AST، ولكن هذه المرة يدخل إلى أجسام الدوال، مهيئات المتغيرات، والتعبيرات، ويقوم بإجراء الفحوصات العميقة.
    *   **الناتج:** شجرة AST "مُخصَّبة" (Annotated AST) بمعلومات الأنواع والرموز، وقائمة بالأخطاء الدلالية.

**2. المكونات الرئيسية للتحليل الدلالي:**

*   **إدارة جدول الرموز (Symbol Table Management):**
    *   **الوظيفة:** هو هيكل بيانات هرمي يتتبع جميع المعرفات (متغيرات، دوال، أنواع، إلخ) ونطاقاتها (global, module, function, block).
    *   **التحققات:**
        *   **الرمز غير معرف:** الكشف عن استخدام متغير أو دالة لم يتم تعريفها.
        *   **إعادة تعريف الرمز:** الكشف عن تعريف متغيرين بنفس الاسم في نفس النطاق.

*   **فحص الأنواع (Type Checking):**
    *   **الوظيفة:** هو قلب التحليل الدلالي. يقوم بالتحقق من توافق الأنواع في كل عملية.
    *   **التحققات:**
        *   **توافق العمليات:** هل يمكنك جمع (`+`) `int` مع `float`؟ هل يمكنك تطبيق `!` على `string`؟
        *   **توافق التعيين:** هل يمكنك تعيين قيمة من نوع `string` لمتغير تم تعريفه كـ `int`؟
        *   **توافق استدعاء الدوال:** هل عدد ونوع الوسائط المُمررة للدالة يطابق تعريفها؟
        *   **توافق الإرجاع:** هل القيمة التي ترجعها الدالة تتوافق مع نوع الإرجاع المُعلن؟
        *   **الوصول للأعضاء:** هل الهيكل `Point` يحتوي فعلاً على حقل `z`؟
    *   **استدلال الأنواع (Type Inference):** تحديد نوع متغير مثل `let x = 5 + 2;` (سيتم استنتاج أنه `int`).

*   **فحص الملكية والاستعارة (Ownership & Borrowing Checking):**
    *   **الوظيفة:** (الجزء الأكثر تعقيدًا) يفرض قواعد سلامة الذاكرة وقت الترجمة.
    *   **التحققات:**
        *   **استخدام بعد النقل (Use after move):** منع استخدام متغير بعد نقل ملكية قيمته.
        *   **تعارض الاستعارات:** منع إنشاء استعارة قابلة للتغيير (`&mut`) أثناء وجود أي استعارة أخرى، أو إنشاء استعارة غير قابلة للتغيير (`&`) أثناء وجود استعارة قابلة للتغيير.
        *   **صلاحية المراجع:** التأكد من أن المرجع لا يعيش أطول من القيمة التي يشير إليها (منع المراجع المعلقة).

*   **التحليل المنطقي (Logic Analysis):**
    *   **الوظيفة:** التحقق من صحة واتساق الأجزاء المنطقية.
    *   **التحققات:**
        *   **صحة الوسائط (Arity):** التأكد من أن عدد ونوع الوسائط في الحقائق والقواعد والاستعلامات يتطابق مع تعريف العلاقة (`relation`).
        *   **سلامة المتغيرات:** التأكد من أن المتغيرات المنطقية المستخدمة في جسم القاعدة "مقيدة" (لها قيمة محتملة) قبل استخدامها في عمليات مثل الحساب أو النفي.

*   **تحليل تكامل المجالات (Domain Integration Analysis):**
    *   **الوظيفة:** التحقق من صحة التفاعلات بين النماذج المختلفة.
    *   **التحققات:**
        *   هل يتم تمرير `Tensor` بالشكل الصحيح لنموذج `Model`؟
        *   هل يتم تطبيق قوة (`Force`) على `RigidBody` وليس على `Camera`؟
        *   هل نتيجة الاستعلام المنطقي (`query_prove`) تُستخدم كقيمة `bool` في جملة `if`؟

**الخلاصة:** هذه المرحلة تضمن أن الكود ليس صحيحًا شكليًا فحسب، بل صحيح منطقيًا ومتوافق مع قواعد اللغة. إذا نجح الكود في اجتياز هذه المرحلة، يصبح "مفهومًا" بالكامل وجاهزًا للترجمة إلى لغة الآلة.

***

### **المرحلة الرابعة: الترجمة الأولية - توليد الكود الوسيط (The Intermediate Representation)**

**الهدف:** تحويل شجرة النحو المجردة (AST) — التي تم التحقق من صحتها دلاليًا في المرحلة السابقة — إلى تمثيل أقل تجريدًا وأقرب إلى لغة الآلة، يُعرف بـ **الكود الوسيط (Intermediate Representation - IR)**.

هذه المرحلة تعمل كجسر حاسم بين فهم اللغة (الواجهة الأمامية) وتوليد كود الآلة الفعلي (الواجهة الخلفية).

**1. لماذا نحتاج إلى كود وسيط (IR)؟**

*   **فصل الاهتمامات (Separation of Concerns):** الـ IR يفصل بين تحليل اللغة المصدرية (Frontend) وتوليد الكود لمنصات مختلفة (Backend). هذا يعني أنه يمكننا كتابة Backend جديد لهندسة معمارية جديدة (مثل ARM أو RISC-V) دون الحاجة لتغيير الـ Frontend، والعكس صحيح.
*   **تسهيل التحسين (Optimization):** معظم خوارزميات تحسين المترجمات (مثل إزالة الكود الميت، نشر الثوابت) مصممة للعمل على هياكل IR منخفضة المستوى وليس على الـ AST مباشرة.
*   **استهداف منصات متعددة (Multi-platform Targeting):** يمكن استخدام نفس الـ IR لتوليد كود لمنصات مختلفة مثل وحدات المعالجة المركزية (CPU)، وحدات معالجة الرسومات (GPU)، أو حتى الويب عبر WebAssembly.

**2. اختيار الـ IR للغة البيان:**

نظرًا لأهداف البيان في الأداء العالي، واستهداف منصات متعددة، ودعم الترجمة المسبقة (AOT) والوقتية (JIT)، فإن **LLVM IR** هو الخيار الأنسب والأكثر قوة.

*   **LLVM IR:** هو IR معروف، قوي، ومستخدم على نطاق واسع في لغات مثل Rust, Swift, و Clang. يوفر مجموعة غنية من التعليمات، بنية تحتية قوية للتحسين، و Backends جاهزة لتوليد كود آلة عالي الجودة لمعظم المعالجات الحديثة.

**3. عملية توليد LLVM IR:**

يقوم مولد الـ IR (IR Generator) بالمرور على الـ AST (الذي تم تخصيبه بمعلومات من التحليل الدلالي) ويقوم بترجمة كل عقدة إلى تعليمات LLVM IR المقابلة.

*   **الأداة المقترحة للتنفيذ:** مكتبة `inkwell` في Rust، التي توفر روابط آمنة لواجهة برمجة تطبيقات LLVM.

**أمثلة على الترجمة:**

| بناء لغة البيان (AlBayan) | ترجمته إلى LLVM IR (بشكل مفاهيمي) |
| :--- | :--- |
| `let x: int = 10;` | `alloca i64` (تخصيص مساحة للمتغير `x` على المكدس)<br>`store i64 10, i64* %x` (تخزين القيمة 10 في `x`) |
| `let y = x + 5;` | `load i64, i64* %x` (تحميل قيمة `x`)<br>`add i64 %loaded_x, 5` (إجراء عملية الجمع) |
| `if condition { ... } else { ... }` | `icmp` (مقارنة الشرط)<br>`cond_br` (تفرع شرطي إلى كتلة `then` أو `else`) |
| `my_func(a, b);` | `call @my_func(i64 %a, i64 %b)` (استدعاء دالة LLVM) |
| `print("Hello");` | `call void @albayan_rt_print_string(i8* %str_ptr)` (استدعاء دالة من **وقت التشغيل**) |

**4. التفاعل مع وقت التشغيل (Runtime Interaction):**

ليست كل ميزات لغة البيان يمكن ترجمتها مباشرة إلى تعليمات آلة بسيطة. الميزات الديناميكية والمعقدة مثل البرمجة المنطقية، عمليات الذكاء الاصطناعي، إدارة الذاكرة الديناميكية (مثل `List<T>`)، وعمليات الإدخال/الإخراج تُترك لـ **مكتبة وقت التشغيل (Runtime Library)**.

*   **الوظيفة:** مولد الـ IR يقوم بتوليد تعليمات `call` لاستدعاء دوال محددة في وقت التشغيل.
*   **مثال:** عند مواجهة `query_solve { ... }`, يقوم مولد الـ IR بتجميع أهداف الاستعلام وتوليد استدعاء لدالة وقت التشغيل مثل `albayan_rt_query_solve(...)`.

**الخلاصة:** هذه المرحلة تحول الـ AST المفهوم دلاليًا إلى لغة تجميع مجردة ومنخفضة المستوى (LLVM IR). الكود الآن في شكل مثالي لتطبيق التحسينات المعقدة ثم ترجمته إلى لغة الآلة النهائية.

***

### **المرحلة الخامسة: الخدمات الأساسية - تصميم وقت التشغيل (The Runtime)**

**الهدف:** بناء المكتبة الأساسية والخدمات التي يحتاجها كود البيان المُترجم لكي يعمل بشكل صحيح. وقت التشغيل هو الجسر بين الكود المُترجم عالي المستوى ونظام التشغيل والعتاد، ويوفر تحقيقًا للميزات الديناميكية التي لا يمكن ترجمتها بالكامل إلى كود آلة ثابت.

إذا كان المترجم هو "البنّاء" الذي يبني المنزل، فإن وقت التشغيل هو "البنية التحتية" التي يعتمد عليها المنزل (مثل شبكات الكهرباء والماء).

**1. لماذا نحتاج إلى وقت تشغيل؟**

لغة البيان تحتوي على ميزات قوية تتجاوز قدرات تعليمات المعالج البسيطة. وقت التشغيل مسؤول عن توفير هذه القدرات، مثل:

*   **البرمجة المنطقية:** لا يمكن للمعالج أن يفهم `query_solve` مباشرة. وقت التشغيل يوفر "محرك استدلال" يقوم بتخزين الحقائق والقواعد وتنفيذ الاستعلامات.
*   **الذكاء الاصطناعي:** تشغيل نماذج التعلم الآلي يتطلب مكتبات متخصصة (مثل ONNX Runtime أو TensorFlow Lite). وقت التشغيل يوفر طبقة تجريد فوق هذه المكتبات.
*   **إدارة الذاكرة الديناميكية:** عندما تنشئ قائمة (`List<T>`) يمكن أن تنمو وتتقلص، يجب تخصيص ذاكرتها على "الكومة" (Heap). وقت التشغيل يوفر مخصص الذاكرة (Allocator) لإدارة هذه العملية.
*   **التزامن (Concurrency):** إدارة المهام غير المتزامنة (`async/await`) تتطلب مُجدوِلًا (Scheduler) لتوزيع العمل بكفاءة.
*   **التفاعل مع النظام:** عمليات مثل طباعة النصوص (`print`)، قراءة الملفات، أو فتح اتصالات الشبكة تتطلب استدعاءات لنظام التشغيل، ووقت التشغيل يوفر واجهة آمنة وموحدة لها.

**2. المكونات الرئيسية لوقت تشغيل البيان:**

*   **محرك الاستدلال المنطقي (Logic Inference Engine):**
    *   **قاعدة المعرفة (Knowledge Base - KB):** هيكل بيانات فعال لتخزين الحقائق والقواعد مع فهرسة لتسريع البحث.
    *   **محرك التوحيد والحل (Unification & Solver Engine):** ينفذ خوارزميات البحث (مثل Backtracking) للعثور على حلول للاستعلامات.
    *   **واجهة برمجة التطبيقات (API):** يوفر دوال C-ABI مثل `albayan_rt_assert_fact`, `albayan_rt_query_solve` التي يستدعيها الكود المترجم.

*   **دعم الذكاء الاصطناعي (AI Support):**
    *   **محرك استدلال AI:** طبقة تجريد تتكامل مع مكتبات خلفية (مثل ONNX Runtime) لتشغيل نماذج AI على أجهزة مختلفة (CPU, GPU).
    *   **واجهة برمجة التطبيقات (API):** يوفر دوال مثل `albayan_rt_load_model`, `albayan_rt_predict`.

*   **إدارة الذاكرة (Memory Management):**
    *   **المخصص (Allocator):** يوفر دوال مثل `albayan_rt_alloc` و `albayan_rt_dealloc` لإدارة الذاكرة على الكومة.
    *   **إدارة دورة الحياة (Lifetime Management):** يعمل مع الكود المترجم لضمان استدعاء دوال التحرير (`drop`) في الوقت الصحيح بناءً على قواعد الملكية.

*   **دعم التزامن والمجالات (Concurrency & Domain Support):**
    *   **مُجدوِل Async:** لإدارة مهام `async/await`.
    *   **محركات المجالات:** قد يتضمن وقت التشغيل أجزاء تتفاعل مباشرة مع مكتبات الرسومات (Vulkan, Metal) أو الفيزياء (Rapier).

*   **المكتبة القياسية (Standard Library Backend):**
    *   يوفر التنفيذ الفعلي لوظائف المكتبة القياسية التي تتطلب تفاعلًا مع النظام (مثل `std::io`, `std::fs`, `std::net`).

**3. كيفية التفاعل:**

الكود المترجم (LLVM IR) لا يرى تفاصيل وقت التشغيل الداخلية. كل ما يراه هو مجموعة من الدوال الخارجية التي يمكن استدعاؤها.

*   **كود البيان:** `print("Hello");`
*   **التحليل الدلالي:** يفهم أن `print` هي دالة مدمجة تأخذ `string`.
*   **مولد IR:** يترجم هذا إلى: `call void @albayan_rt_print_string(i8* %hello_ptr)`
*   **وقت التشغيل:** يحتوي على التنفيذ الفعلي لدالة `albayan_rt_print_string` المكتوبة بـ Rust والتي تقوم باستدعاء نظام التشغيل للطباعة على الشاشة.

**الخلاصة:** وقت التشغيل هو شريك أساسي للمترجم، حيث يوفر الخدمات الديناميكية والمعقدة التي تجعل ميزات البيان الفريدة ممكنة. يتم تصميمه كمكتبة (مكتوبة بـ Rust في حالتنا) يتم ربطها مع البرنامج النهائي.

***

### **المرحلة السادسة: التحسين والصقل (The Optimizer)**

**الهدف:** تحسين الكود الوسيط (LLVM IR) الذي تم إنتاجه في المرحلة الرابعة لجعله أسرع في التنفيذ، أصغر حجمًا، وأكثر كفاءة في استخدام موارد المعالج والذاكرة.

هذه المرحلة هي بمثابة "مراجعة وتحسين" المخططات الهندسية قبل البدء الفعلي بالبناء النهائي، حيث يتم البحث عن أي طرق لجعل التصميم أفضل وأكثر كفاءة.

**1. لماذا التحسين؟**

الكود الوسيط الذي يتم توليده مباشرة من شجرة النحو المجردة (AST) غالبًا ما يكون بسيطًا ومباشرًا، ولكنه ليس الأمثل. قد يحتوي على:
*   **عمليات متكررة:** حساب نفس القيمة عدة مرات.
*   **كود ميت:** أجزاء من الكود لا يمكن الوصول إليها أبدًا أو لا تؤثر على النتيجة النهائية.
*   **عمليات مكلفة:** استخدام عمليات حسابية بطيئة يمكن استبدالها بعمليات أسرع (مثل استبدال الضرب في 2 بعملية إزاحة بت).
*   **وصول غير فعال للذاكرة:** نمط وصول للذاكرة لا يستغل الذاكرة المؤقتة (Cache) للمعالج بشكل جيد.

**2. أنواع التحسينات (باستخدام LLVM):**

يوفر LLVM مجموعة هائلة من "مسارات التحسين" (Optimization Passes) الجاهزة التي يمكن تطبيقها على الـ IR. تنقسم هذه التحسينات إلى عدة فئات:

*   **التحسينات العددية (Scalar Optimizations):**
    *   **طي الثوابت (Constant Folding):** حساب التعبيرات الثابتة (`2 + 3`) وقت الترجمة واستبدالها بنتيجتها (`5`).
    *   **نشر الثوابت (Constant Propagation):** إذا كان `x = 10;`, يتم استبدال كل استخدام لـ `x` بالقيمة `10` حيثما أمكن.
    *   **إزالة التعبيرات المكررة الشائعة (Common Subexpression Elimination - CSE):** إذا تم حساب `a + b` عدة مرات، يتم حسابها مرة واحدة وتخزين النتيجة.
    *   **إزالة الكود الميت (Dead Code Elimination - DCE):** إزالة المتغيرات، التعليمات، أو الدوال التي لا تُستخدم أبدًا.
    *   **ترقية الذاكرة إلى سجلات (Memory to Register Promotion - Mem2Reg):** (أحد أهم التحسينات) استبدال الوصول المتكرر للذاكرة للمتغيرات المحلية باستخدام سجلات المعالج السريعة.

*   **تحسينات الحلقات (Loop Optimizations):**
    *   **نقل الكود الثابت خارج الحلقة (Loop-Invariant Code Motion - LICM):** نقل أي عملية داخل حلقة لا تعتمد على متغيرات الحلقة إلى خارجها.
    *   **فك تدوير الحلقة (Loop Unrolling):** تكرار جسم الحلقة عدة مرات لتقليل الحمل الزائد للتحكم في الحلقة.

*   **تحسينات الدوال (Function Optimizations):**
    *   **التضمين (Inlining):** استبدال استدعاء دالة صغيرة بجسم الدالة نفسها مباشرة لتقليل تكلفة الاستدعاء.

*   **التحسينات المتقدمة:**
    *   **التحسين الموجه بالبروفايل (Profile-Guided Optimization - PGO):** استخدام معلومات من تشغيلات سابقة للبرنامج لتوجيه قرارات التحسين (مثل أي الفروع في `if` أكثر احتمالاً).
    *   **تحسين وقت الربط (Link-Time Optimization - LTO):** تأجيل بعض التحسينات (مثل Inlining عبر الملفات) إلى مرحلة الربط النهائية.

**3. التنفيذ في مترجم البيان:**

*   **الاعتماد على LLVM:** لن نقوم بإعادة اختراع هذه الخوارزميات المعقدة. سنقوم بتكوين وتشغيل مسارات التحسين التي يوفرها LLVM.
*   **مستويات التحسين:** ستوفر أداة `albayan` خيارات للتحكم في مستوى التحسين:
    *   **وضع التطوير (Debug Mode):** (مثل `albayan build`) قد يستخدم `O0` (بدون تحسين) لسرعة الترجمة وسهولة التصحيح.
    *   **وضع الإصدار (Release Mode):** (مثل `albayan build --release`) سيستخدم `O2` أو `O3` (تحسينات قوية) للحصول على أفضل أداء للتنفيذ.
*   **الأداة المقترحة للتنفيذ:** استخدام `PassManagerBuilder` و `PassManager` في مكتبة `inkwell` لتكوين وتشغيل خط أنابيب التحسين المناسب.

**4. تحسينات خاصة بالبيان:**

بالإضافة إلى تحسينات LLVM العامة، يمكن إجراء تحسينات خاصة باللغة على مستويات أعلى:

*   **تحسين الاستعلام المنطقي (Query Optimization):** قبل توليد IR، يمكن إعادة ترتيب أهداف الاستعلام لتقليل فضاء البحث بشكل كبير.
*   **تحسين عمليات AI:** يمكن دمج عدة عمليات على التنسورات (مثل Conv -> BatchNorm -> ReLU) في عملية واحدة مُحسَّنة (Operator Fusion)، ربما باستخدام MLIR كطبقة وسيطة إضافية.

**الخلاصة:** مرحلة التحسين هي المسؤولة عن تحويل الكود الوسيط الصحيح وظيفيًا إلى كود عالي الأداء. بالاعتماد على البنية التحتية القوية لـ LLVM، يمكن للغة البيان تحقيق أداء تنافسي مع اللغات المترجمة الأخرى.

***

### **المرحلة السابعة: البناء النهائي - توليد الكود والتجميع (The Backend)**

**الهدف:** تحويل الكود الوسيط المُحسَّن (Optimized LLVM IR) إلى كود آلة قابل للتنفيذ (Executable Code) لمنصة مستهدفة محددة (مثل Windows x86-64, Linux ARM64, أو WebAssembly).

هذه هي المرحلة التي يتم فيها "البناء الفعلي" للبرنامج النهائي القابل للتشغيل، بناءً على المخططات الهندسية المُحسَّنة من المراحل السابقة.

**1. المكونات الرئيسية للواجهة الخلفية (Backend):**

*   **مولد كود الآلة (Machine Code Generation):**
    *   **الوظيفة:** يأخذ LLVM IR ويترجمه إلى تعليمات لغة التجميع (Assembly) الخاصة بالمعالج المستهدف (Target Architecture).
    *   **العمليات:**
        *   **اختيار التعليمات (Instruction Selection):** اختيار تعليمات الآلة المثلى لكل عملية في الـ IR.
        *   **تخصيص السجلات (Register Allocation):** تعيين المتغيرات لسجلات المعالج الفعلية بكفاءة.
        *   **جدولة التعليمات (Instruction Scheduling):** إعادة ترتيب التعليمات للاستفادة القصوى من البنية الداخلية للمعالج.
    *   **التنفيذ:** يتم كل هذا تلقائيًا بواسطة **الواجهة الخلفية (Backend) لـ LLVM** الخاصة بالمنصة المستهدفة.

*   **المُجمِّع (Assembler):**
    *   **الوظيفة:** يحول كود لغة التجميع إلى **كود الكائن (Object Code)** — وهو كود آلة ثنائي يحتوي على التعليمات الفعلية والبيانات، ولكنه ليس قابلاً للتنفيذ بعد لأنه قد يشير إلى رموز خارجية (مثل `printf` أو دوال وقت التشغيل). يتم تخزين هذا في ملفات (`.o` على Linux/macOS, `.obj` على Windows).
    *   **التنفيذ:** يتم أيضًا بواسطة LLVM.

*   **الرابط (Linker):**
    *   **الوظيفة:** هذه هي الخطوة النهائية. يقوم الرابط بجمع واحد أو أكثر من ملفات كود الكائن وربطها معًا لحل الإشارات الخارجية وإنتاج ملف تنفيذي نهائي أو مكتبة ديناميكية.
    *   **المدخلات:**
        1.  **ملف الكائن الخاص ببرنامجك:** (مثل `my_program.o`) الذي تم إنشاؤه بواسطة LLVM.
        2.  **مكتبة وقت تشغيل البيان:** (`libalbayan_runtime.a` أو `.so/.dll`) التي تحتوي على تنفيذ محرك المنطق، دعم AI، إدارة الذاكرة، إلخ.
        3.  **المكتبات القياسية للنظام:** (مثل `libc`, `libm`) التي توفر وظائف نظام التشغيل الأساسية.
        4.  **أي مكتبات خارجية أخرى:** (مثل مكتبات الرسومات، الفيزياء، إلخ).
    *   **المخرجات:** ملف تنفيذي (مثل `my_program` أو `my_program.exe`).
    *   **التنفيذ:** يتم استدعاء رابط النظام الخارجي (مثل `ld`, `gcc`, `clang`, أو `link.exe`) بواسطة مترجم البيان. يمكن استخدام مكتبة مساعدة مثل `cc` crate في Rust لإدارة هذه العملية المعقدة.

**2. استهداف منصات متعددة (Cross-Compilation):**

تسمح بنية LLVM للغة البيان باستهداف منصات مختلفة عن تلك التي يعمل عليها المترجم.
*   **الوظيفة:** يمكن لمترجم البيان الذي يعمل على macOS (ARM64) أن ينتج ملفًا تنفيذيًا لـ Windows (x86-64) عن طريق تحديد "الهدف الثلاثي" (Target Triple) المناسب، مثل `--target x86_64-pc-windows-msvc`.
*   **التحدي:** يتطلب هذا وجود LLVM Backend المناسب وسلسلة أدوات (Toolchain) الربط للمنصة المستهدفة.

**3. الترجمة الوقتية (Just-In-Time - JIT Compilation):**

كبديل لإنشاء ملف تنفيذي، يمكن للغة البيان دعم الترجمة الفورية.
*   **الوظيفة:** بدلاً من كتابة كود الآلة إلى ملف، يقوم محرك تنفيذ LLVM (Execution Engine) بترجمة الـ IR إلى كود آلة في الذاكرة وتنفيذه مباشرة.
*   **الاستخدام:**
    *   **REPL (Read-Eval-Print Loop):** بيئة تفاعلية لتجربة كود البيان سطرًا بسطر.
    *   **التشغيل السريع للسكربتات:** (مثل `albayan run my_script.ab`) لتجنب خطوة إنشاء الملف التنفيذي.

**الخلاصة:** الواجهة الخلفية، بالاعتماد الكلي على LLVM، تحول الكود الوسيط المُحسَّن إلى برنامج فعلي يمكن تشغيله على جهاز الكمبيوتر. العملية تنتهي بالربط مع مكتبة وقت التشغيل الحيوية، مما يجمع كل الأجزاء معًا.

**لقد أكملنا الآن جميع المراحل السبع لعملية الترجمة الأساسية!**
---

 إليك ملخص يجمع كل المراحل في نظرة شاملة واحدة.

***

### **ملخص المراحل: من الفكرة إلى التنفيذ - دورة حياة مترجم البيان**

هذا هو ملخص الرحلة الكاملة التي يقطعها كود لغة البيان، من كونه فكرة في ذهن المبرمج إلى برنامج يعمل على جهاز الكمبيوتر.

**الفكرة** -> **الكود المصدري (Source Code)**
```albayancode
// my_program.ab
fn main() {
    let x = 10;
    if x > 5 {
        print("x is greater than 5");
    }
}
```
---
**الواجهة الأمامية (Frontend): فهم الكود**
---

**المرحلة 1: الأساس والمواصفات (The Blueprint)**
*   **ماذا يحدث؟** تحديد قواعد اللغة وفلسفتها.
*   **النتيجة:** وثيقة مواصفات تحدد بناء الجملة، الكلمات المفتاحية، نظام الأنواع، وقدرات اللغة.

**المرحلة 2: المحلل المعجمي والنحوي (The Parser)**
*   **ماذا يحدث؟**
    1.  **Lexer:** يقرأ النص ويقسمه إلى "رموز" (Tokens): `[fn, main, (, ), {, let, x, =, 10, ;, if, ...]`
    2.  **Parser:** يأخذ الرموز ويبني "شجرة النحو المجردة" (AST) التي تمثل هيكل الكود.
*   **النتيجة:** تمثيل هرمي للكود (AST) جاهز للفحص الدلالي.

**المرحلة 3: التحليل الدلالي (The Analyzer)**
*   **ماذا يحدث؟** فحص الـ AST للتأكد من صحة "المعنى".
    *   **فحص الأنواع:** هل `x > 5` عملية صالحة؟ (نعم، `int` يمكن مقارنته بـ `int`).
    *   **فحص النطاقات:** هل المتغير `x` مُعرَّف عند استخدامه؟ (نعم، تم تعريفه بـ `let`).
    *   **فحص الملكية:** (في هذه الحالة البسيطة) `x` هو `Copy`، لذلك لا توجد مشاكل ملكية.
    *   **فحص المنطق والمجالات:** (لا ينطبق هنا).
*   **النتيجة:** شجرة AST مُدقَّقة ومُخصَّبة بمعلومات الأنواع والرموز. إذا تم العثور على أخطاء (مثل `if "hello" { ... }`)، تتوقف عملية الترجمة هنا.

---
**الواجهة الوسيطة (Middle-end): الترجمة والتحسين**
---

**المرحلة 4: توليد الكود الوسيط (IR Generation)**
*   **ماذا يحدث؟** ترجمة الـ AST الصحيح دلاليًا إلى "كود وسيط" منخفض المستوى (LLVM IR).
*   **النتيجة:** تمثيل للكود في لغة تجميع مجردة، مستقلة عن المعالج.
    ```llvm
    ; (LLVM IR - Conceptual)
    define void @main() {
      entry:
        %x = alloca i64
        store i64 10, i64* %x
        %loaded_x = load i64, i64* %x
        %cond = icmp sgt i64 %loaded_x, 5
        br i1 %cond, label %then, label %end_if
      then:
        call void @albayan_rt_print_string(...)
        br label %end_if
      end_if:
        ret void
    }
    ```

**المرحلة 5: وقت التشغيل (The Runtime)**
*   **ماذا يحدث؟** (يعمل بالتوازي) يوفر مكتبة تحتوي على الدوال الأساسية التي لا يمكن للمعالج تنفيذها مباشرة (`albayan_rt_print_string`, `albayan_rt_query_solve`, إلخ).
*   **النتيجة:** مكتبة (`libalbayan_runtime.a` أو `.so`) جاهزة للربط مع البرنامج.

**المرحلة 6: التحسين (The Optimizer)**
*   **ماذا يحدث؟** يتم تطبيق سلسلة من التحسينات على LLVM IR (مثل إزالة المتغيرات غير المستخدمة، حساب العمليات الثابتة مسبقًا).
*   **النتيجة:** نسخة مُحسَّنة من LLVM IR تكون أسرع وأكثر كفاءة.

---
**الواجهة الخلفية (Backend): البناء النهائي**
---

**المرحلة 7: توليد الكود والتجميع (The Backend)**
*   **ماذا يحدث؟**
    1.  **Code Generation:** LLVM يترجم الـ IR المُحسَّن إلى لغة التجميع الخاصة بالمعالج المستهدف.
    2.  **Assembler:** LLVM يحول لغة التجميع إلى "كود كائن" ثنائي (`.o` أو `.obj`).
    3.  **Linker:** الرابط يجمع كود الكائن الخاص ببرنامجك مع مكتبة وقت التشغيل (المرحلة 5) ومكتبات النظام الأخرى.
*   **النتيجة النهائية:** **ملف تنفيذي (Executable)** جاهز للتشغيل!

**التنفيذ** -> **البرنامج يعمل!**
```
x is greater than 5
```

هذه هي دورة الحياة الكاملة التي تحول الأفكار المكتوبة بلغة البيان إلى برامج حقيقية تعمل بكفاءة وأمان.
